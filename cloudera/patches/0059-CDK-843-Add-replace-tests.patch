From 7434104685392b5bc0ca65fa0620a2eb895ac3d3 Mon Sep 17 00:00:00 2001
From: Ryan Blue <blue@apache.org>
Date: Sat, 25 Apr 2015 16:29:57 -0700
Subject: [PATCH 059/140] CDK-843: Add replace tests.

---
 .../data/spi/filesystem/FileSystemDataset.java     |    5 +-
 .../spi/filesystem/FileSystemPartitionView.java    |   17 +-
 .../spi/filesystem/TestPartitionReplacement.java   |  290 ++++++++++++++++++++
 3 files changed, 304 insertions(+), 8 deletions(-)
 create mode 100644 kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java

diff --git a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
index 8e99aa3..0760587 100644
--- a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
+++ b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
@@ -380,7 +380,10 @@ public class FileSystemDataset<E> extends AbstractDataset<E> implements
 
   @Override
   public boolean canReplace(View<E> part) {
-    if (part instanceof FileSystemView) {
+    if (!descriptor.isPartitioned()) {
+      // don't attempt to replace the root directory
+      return false;
+    } else if (part instanceof FileSystemView) {
       return equals(part.getDataset()) &&
           ((FileSystemView) part).getConstraints().alignedWithBoundaries();
     } else if (part instanceof FileSystemDataset) {
diff --git a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemPartitionView.java b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemPartitionView.java
index 58bb2fb..0298992 100644
--- a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemPartitionView.java
+++ b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemPartitionView.java
@@ -111,8 +111,8 @@ class FileSystemPartitionView<E> extends FileSystemView<E>
         new Predicate<PartitionView<E>>() {
           @Override
           public boolean apply(@Nullable PartitionView<E> input) {
-            return input != null && input.getLocation().getPath()
-                .startsWith(location.toUri().getPath());
+            return input != null &&
+                contains(location.toUri(), root, input.getLocation());
           }
         });
   }
@@ -153,6 +153,11 @@ class FileSystemPartitionView<E> extends FileSystemView<E>
     return Objects.hashCode(super.hashCode(), location);
   }
 
+  private static boolean contains(URI location, Path root, URI relative) {
+    URI full = new Path(root, relative.getPath()).toUri();
+    return !location.relativize(full).isAbsolute();
+  }
+
   @edu.umd.cs.findbugs.annotations.SuppressWarnings(
       value="NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE",
       justification="Null value checked by precondition")
@@ -249,12 +254,10 @@ class FileSystemPartitionView<E> extends FileSystemView<E>
 
     @Override
     public boolean apply(@Nullable StorageKey key) {
-      return (key != null && key.getPath() != null && contains(key.getPath()));
+      return (key != null &&
+          key.getPath() != null &&
+          contains(location, root, key.getPath().toUri()));
     }
 
-    private boolean contains(Path relative) {
-      URI full = new Path(root, relative.toUri().getPath()).toUri();
-      return !location.relativize(full).isAbsolute();
-    }
   }
 }
diff --git a/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java b/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java
new file mode 100644
index 0000000..c1367d1
--- /dev/null
+++ b/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2015 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kitesdk.data.spi.filesystem;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Iterators;
+import com.google.common.collect.Sets;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Set;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
+import org.junit.After;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+import org.kitesdk.data.DatasetDescriptor;
+import org.kitesdk.data.DatasetWriter;
+import org.kitesdk.data.Datasets;
+import org.kitesdk.data.LocalFileSystem;
+import org.kitesdk.data.PartitionStrategy;
+import org.kitesdk.data.TestHelpers;
+import org.kitesdk.data.ValidationException;
+import org.kitesdk.data.View;
+
+public class TestPartitionReplacement {
+  public static class TestRecord {
+    private long id;
+    private String data;
+  }
+
+  private FileSystemDataset<TestRecord> unpartitioned = null;
+  private FileSystemDataset<TestRecord> partitioned = null;
+  private FileSystemDataset<TestRecord> temporary = null;
+
+  @Before
+  public void createTestDatasets() {
+    Datasets.delete("dataset:file:/tmp/datasets/unpartitioned");
+    Datasets.delete("dataset:file:/tmp/datasets/partitioned");
+    Datasets.delete("dataset:file:/tmp/datasets/temporary");
+
+    DatasetDescriptor descriptor = new DatasetDescriptor.Builder()
+        .schema(TestRecord.class)
+        .build();
+    unpartitioned = Datasets.create("dataset:file:/tmp/datasets/unpartitioned",
+        descriptor, TestRecord.class);
+
+    descriptor = new DatasetDescriptor.Builder(descriptor)
+        .property("kite.writer.cache-size", "20")
+        .partitionStrategy(new PartitionStrategy.Builder()
+            .hash("id", 4)
+            .build())
+        .build();
+    partitioned = Datasets.create("dataset:file:/tmp/datasets/partitioned",
+        descriptor, TestRecord.class);
+
+    // create a second dataset with the same partitioning for replacement parts
+    temporary = Datasets.create("dataset:file:/tmp/datasets/temporary",
+        descriptor, TestRecord.class);
+
+    writeTestRecords(unpartitioned);
+    writeTestRecords(partitioned);
+    writeTestRecords(temporary);
+  }
+
+  @After
+  public void removeTestDatasets() {
+    Datasets.delete("dataset:file:/tmp/datasets/unpartitioned");
+    Datasets.delete("dataset:file:/tmp/datasets/partitioned");
+    Datasets.delete("dataset:file:/tmp/datasets/temporary");
+  }
+
+  @Test
+  public void testUnpartitionedReplace() {
+    Assert.assertFalse("Should not allow replacing an unpartitioned dataset",
+        unpartitioned.canReplace(unpartitioned));
+  }
+
+  @Test
+  public void testReplaceWithDifferentStrategy() {
+    Assert.assertTrue("Should allow replacing a whole dataset",
+        partitioned.canReplace(partitioned));
+
+    TestHelpers.assertThrows(
+        "Should not allow replacement with a different partition strategy",
+        ValidationException.class, new Runnable() {
+          @Override
+          public void run() {
+            partitioned.replace(unpartitioned);
+          }
+        });
+  }
+
+  @Test
+  public void testPartitionedReplace() {
+    Assert.assertTrue("Should allow replacing a whole dataset",
+        partitioned.canReplace(partitioned));
+    Assert.assertTrue(
+        "Should not allow replacement test with a different dataset",
+        partitioned.canReplace(partitioned));
+
+    Set<String> originalFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Set<String> replacementFiles = Sets.newHashSet(
+        Iterators.transform(temporary.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Sanity check",
+        originalFiles.size(), replacementFiles.size());
+    Assert.assertFalse("Sanity check", originalFiles.equals(replacementFiles));
+
+    partitioned.replace(temporary);
+
+    Set<String> replacedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Should contain the replacement files",
+        replacementFiles, replacedFiles);
+  }
+
+  @Test
+  public void testReplaceSinglePartition() {
+    FileSystemPartitionView<TestRecord> partition0 = partitioned.getPartitionView(
+        new Path("id_hash=0"));
+    FileSystemPartitionView<TestRecord> temp0 = temporary.getPartitionView(
+        new Path("id_hash=0"));
+
+    Assert.assertTrue("Should allow replacing a single partition",
+        partitioned.canReplace(partition0));
+    Assert.assertFalse(
+        "Should not allow replacement test with a different dataset",
+        partitioned.canReplace(temp0));
+
+    Set<String> replacementFiles = Sets.newHashSet(
+        Iterators.transform(temp0.pathIterator(), new GetFilename()));
+    Set<String> originalPartitionFiles = Sets.newHashSet(
+        Iterators.transform(partition0.pathIterator(), new GetFilename()));
+
+    Assert.assertEquals("Sanity check",
+        originalPartitionFiles.size(), replacementFiles.size());
+    Assert.assertFalse("Sanity check",
+        originalPartitionFiles.equals(replacementFiles));
+
+    Set<String> expectedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    expectedFiles.removeAll(originalPartitionFiles);
+    expectedFiles.addAll(replacementFiles);
+
+    partitioned.replace(temp0);
+
+    Set<String> replacedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Should contain the replacement files",
+        expectedFiles, replacedFiles);
+  }
+
+  @Test
+  public void testReplacePartitionsByConstraints() throws IOException {
+    // like testReplaceSinglePartition, this will replace partition0 with temp0
+    // but, this will also remove partitions that have equivalent constraints
+    // to simulate the case where directories 0, hash_0, id_hash=0, and
+    // id_hash=00 are compacted to a single replacement folder
+
+    FileSystemPartitionView<TestRecord> partition0 = partitioned.getPartitionView(
+        new Path("id_hash=0"));
+    FileSystemPartitionView<TestRecord> temp0 = temporary.getPartitionView(
+        new Path("id_hash=0"));
+
+    Set<String> replacementFiles = Sets.newHashSet(
+        Iterators.transform(temp0.pathIterator(), new GetFilename()));
+
+    // move other partitions so they match the partition0 constraint
+    FileSystem local = LocalFileSystem.getInstance();
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=1"),
+        new Path(partitioned.getDirectory(), "0"));
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=2"),
+        new Path(partitioned.getDirectory(), "hash=0"));
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=3"),
+        new Path(partitioned.getDirectory(), "id_hash=00"));
+
+    Assert.assertTrue("Should allow replacing a single partition",
+        partitioned.canReplace(partition0));
+    Assert.assertFalse(
+        "Should not allow replacement test with a different dataset",
+        partitioned.canReplace(temp0));
+
+    partitioned.replace(temp0);
+
+    Set<String> replacedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Should contain the replacement files",
+        replacementFiles, replacedFiles);
+
+    Iterator<Path> dirIterator = partitioned.dirIterator();
+    Path onlyDirectory = dirIterator.next();
+    Assert.assertFalse("Should contain only one directory",
+        dirIterator.hasNext());
+    Assert.assertEquals("Should have the correct directory name",
+        "id_hash=0", onlyDirectory.getName());
+  }
+
+  @Test
+  public void testReplacePartitionsByConstraintsWithoutOriginal() throws IOException {
+    // like testReplacePartitionsByConstraints, but the target partition does
+    // not exist
+
+    FileSystemPartitionView<TestRecord> temp0 = temporary.getPartitionView(
+        new Path("id_hash=0"));
+
+    Set<String> replacementFiles = Sets.newHashSet(
+        Iterators.transform(temp0.pathIterator(), new GetFilename()));
+
+    // move other partitions so they match the partition0 constraint
+    FileSystem local = LocalFileSystem.getInstance();
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=0"),
+        new Path(partitioned.getDirectory(), "id-hash=0"));
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=1"),
+        new Path(partitioned.getDirectory(), "0"));
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=2"),
+        new Path(partitioned.getDirectory(), "hash=0"));
+    local.rename(
+        new Path(partitioned.getDirectory(), "id_hash=3"),
+        new Path(partitioned.getDirectory(), "id_hash=00"));
+
+    FileSystemPartitionView<TestRecord> partition0 = partitioned.getPartitionView(
+        new Path("id-hash=0"));
+
+    Assert.assertTrue("Should allow replacing a single partition",
+        partitioned.canReplace(partition0));
+    Assert.assertFalse(
+        "Should not allow replacement test with a different dataset",
+        partitioned.canReplace(temp0));
+
+    partitioned.replace(temp0);
+
+    Set<String> replacedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Should contain the replacement files",
+        replacementFiles, replacedFiles);
+
+    Iterator<Path> dirIterator = partitioned.dirIterator();
+    Path onlyDirectory = dirIterator.next();
+    Assert.assertFalse("Should contain only one directory",
+        dirIterator.hasNext());
+    Assert.assertEquals("Should have the correct directory name",
+        "id_hash=0", onlyDirectory.getName());
+  }
+
+  private static class GetFilename implements Function<Path, String> {
+    @Override
+    public String apply(Path path) {
+      return path.getName();
+    }
+  }
+
+  private static void writeTestRecords(View<TestRecord> view) {
+    DatasetWriter<TestRecord> writer = null;
+    try {
+      writer = view.newWriter();
+      for (int i = 0; i < 10; i += 1) {
+        TestRecord record = new TestRecord();
+        record.id = i;
+        record.data = "test-" + i;
+        writer.write(record);
+      }
+
+    } finally {
+      if (writer != null) {
+        writer.close();
+      }
+    }
+  }
+}
-- 
1.7.9.5

