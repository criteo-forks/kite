From e5c433dff69a1888d3f89957a2537ebfccee5a7d Mon Sep 17 00:00:00 2001
From: Ryan Blue <blue@apache.org>
Date: Wed, 10 Jun 2015 21:00:18 -0700
Subject: [PATCH 079/115] CDK-1017: Remove all target partitions in replace.

This removes any partitions in the view being replaced, even if the
replacement doesn't have the partition.
---
 .../java/org/kitesdk/data/spi/Replaceable.java     |    4 +-
 .../data/spi/filesystem/FileSystemDataset.java     |   27 +++++++--
 .../spi/filesystem/TestPartitionReplacement.java   |   59 +++++++++++++++++---
 .../data/mapreduce/DatasetKeyOutputFormat.java     |    5 +-
 4 files changed, 75 insertions(+), 20 deletions(-)

diff --git a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/Replaceable.java b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/Replaceable.java
index adf5462..043776e 100644
--- a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/Replaceable.java
+++ b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/Replaceable.java
@@ -30,12 +30,12 @@ public interface Replaceable<T> {
    * @param part the object to replace parts of this
    * @return {@code true} if the object can replace parts of this
    */
-  public boolean canReplace(T part);
+  boolean canReplace(T part);
 
   /**
    * Replace part of {@code this} with the {@code replacement} object.
    *
    * @param replacement the object to replace parts of this
    */
-  public void replace(T replacement);
+  void replace(T target, T replacement);
 }
diff --git a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
index aba40c6..062d56b 100644
--- a/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
+++ b/kite-data/kite-data-core/src/main/java/org/kitesdk/data/spi/filesystem/FileSystemDataset.java
@@ -17,6 +17,7 @@ package org.kitesdk.data.spi.filesystem;
 
 import java.util.Iterator;
 import com.google.common.collect.Iterables;
+import com.google.common.collect.Sets;
 import org.apache.hadoop.mapreduce.InputFormat;
 import org.kitesdk.data.Dataset;
 import org.kitesdk.data.DatasetDescriptor;
@@ -54,6 +55,7 @@ import javax.annotation.Nullable;
 import java.io.IOException;
 import java.net.URI;
 import java.util.List;
+import java.util.Set;
 import org.apache.avro.generic.IndexedRecord;
 import org.kitesdk.data.Formats;
 
@@ -419,15 +421,19 @@ public class FileSystemDataset<E> extends AbstractDataset<E> implements
   }
 
   @Override
-  public void replace(View<E> update) {
-    DatasetDescriptor updateDescriptor = update.getDataset().getDescriptor();
+  public void replace(View<E> target, View<E> replacement) {
+    DatasetDescriptor updateDescriptor = replacement.getDataset().getDescriptor();
 
     // check that the dataset's descriptor can read the update
     Compatibility.checkCompatible(updateDescriptor, descriptor);
 
     if (descriptor.isPartitioned()) {
+      // track current partitions: either replace or delete
+      Set<PartitionView<E>> notReplaced = Sets.newHashSet(
+          target.getCoveringPartitions());
+
       // replace leaf partitions one at a time
-      for (PartitionView<E> src : update.getCoveringPartitions()) {
+      for (PartitionView<E> src : replacement.getCoveringPartitions()) {
         if (src instanceof FileSystemPartitionView) {
           FileSystemPartitionView<E> dest = getPartitionView(
               ((FileSystemPartitionView<E>) src).getRelativeLocation());
@@ -441,13 +447,14 @@ public class FileSystemDataset<E> extends AbstractDataset<E> implements
               .toConstraintsView()
               .getCoveringPartitions();
           for (PartitionView<E> partition : existingPartitions) {
-            FileSystemPartitionView<E> toRemove =
+            FileSystemPartitionView<E> toReplace =
                 (FileSystemPartitionView<E>) partition;
-            Path path = new Path(toRemove.getLocation());
+            Path path = new Path(toReplace.getLocation());
             removals.add(path);
+            notReplaced.remove(toReplace);
             if (partitionListener != null && descriptor.isPartitioned()) {
               partitionListener.partitionDeleted(
-                  namespace, name, toRemove.getRelativeLocation().toString());
+                  namespace, name, toReplace.getRelativeLocation().toString());
             }
           }
 
@@ -466,10 +473,16 @@ public class FileSystemDataset<E> extends AbstractDataset<E> implements
               "Incompatible PartitionView: " + src.getClass().getName());
         }
       }
+
+      // remove the original partitions that were not individually replaced
+      for (PartitionView<E> toRemove : notReplaced) {
+        toRemove.deleteAll();
+      }
+
     } else {
       // stage data in the dataset, remove existing data, then finish the move
       PartitionView<E> srcPartition = Iterables.getOnlyElement(
-          update.getCoveringPartitions());
+          replacement.getCoveringPartitions());
       List<Pair<Path, Path>> staged = FileSystemUtil.stageMove(fileSystem,
           new Path(srcPartition.getLocation()), new Path(unbounded.getLocation()),
           "replace" /* data should replace to recover from a failure */ );
diff --git a/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java b/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java
index a741c66..3e6e371 100644
--- a/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java
+++ b/kite-data/kite-data-core/src/test/java/org/kitesdk/data/spi/filesystem/TestPartitionReplacement.java
@@ -113,7 +113,7 @@ public class TestPartitionReplacement {
     Iterators.transform(temporary.pathIterator(), new GetFilename());
     Assert.assertFalse("Sanity check", originalFiles.equals(replacementFiles));
 
-    unpartitioned.replace(temporary);
+    unpartitioned.replace(unpartitioned, temporary);
 
     Set<String> replacedFiles = Sets.newHashSet(
         Iterators.transform(unpartitioned.pathIterator(), new GetFilename()));
@@ -136,7 +136,7 @@ public class TestPartitionReplacement {
         ValidationException.class, new Runnable() {
           @Override
           public void run() {
-            unpartitioned.replace(partitioned);
+            unpartitioned.replace(unpartitioned, partitioned);
           }
         });
     TestHelpers.assertThrows(
@@ -144,7 +144,7 @@ public class TestPartitionReplacement {
         ValidationException.class, new Runnable() {
           @Override
           public void run() {
-            unpartitioned.replace(partition0);
+            unpartitioned.replace(unpartitioned, partition0);
           }
         });
   }
@@ -159,7 +159,7 @@ public class TestPartitionReplacement {
         ValidationException.class, new Runnable() {
           @Override
           public void run() {
-            partitioned.replace(unpartitioned);
+            partitioned.replace(partitioned, unpartitioned);
           }
         });
   }
@@ -170,7 +170,7 @@ public class TestPartitionReplacement {
         partitioned.canReplace(partitioned));
     Assert.assertTrue(
         "Should not allow replacement test with a different dataset",
-        partitioned.canReplace(partitioned));
+        !partitioned.canReplace(temporary));
 
     Set<String> originalFiles = Sets.newHashSet(
         Iterators.transform(partitioned.pathIterator(), new GetFilename()));
@@ -180,7 +180,7 @@ public class TestPartitionReplacement {
         originalFiles.size(), replacementFiles.size());
     Assert.assertFalse("Sanity check", originalFiles.equals(replacementFiles));
 
-    partitioned.replace(temporary);
+    partitioned.replace(partitioned, temporary);
 
     Set<String> replacedFiles = Sets.newHashSet(
         Iterators.transform(partitioned.pathIterator(), new GetFilename()));
@@ -216,7 +216,7 @@ public class TestPartitionReplacement {
     expectedFiles.removeAll(originalPartitionFiles);
     expectedFiles.addAll(replacementFiles);
 
-    partitioned.replace(temp0);
+    partitioned.replace(partition0, temp0);
 
     Set<String> replacedFiles = Sets.newHashSet(
         Iterators.transform(partitioned.pathIterator(), new GetFilename()));
@@ -257,7 +257,7 @@ public class TestPartitionReplacement {
         "Should not allow replacement test with a different dataset",
         partitioned.canReplace(temp0));
 
-    partitioned.replace(temp0);
+    partitioned.replace(partition0, temp0);
 
     Set<String> replacedFiles = Sets.newHashSet(
         Iterators.transform(partitioned.pathIterator(), new GetFilename()));
@@ -307,7 +307,7 @@ public class TestPartitionReplacement {
         "Should not allow replacement test with a different dataset",
         partitioned.canReplace(temp0));
 
-    partitioned.replace(temp0);
+    partitioned.replace(partition0, temp0);
 
     Set<String> replacedFiles = Sets.newHashSet(
         Iterators.transform(partitioned.pathIterator(), new GetFilename()));
@@ -322,6 +322,47 @@ public class TestPartitionReplacement {
         "id_hash=0", onlyDirectory.getName());
   }
 
+  @Test
+  public void testReplaceRemovesPartitionsNotIndividuallyReplaced() throws IOException {
+    // remove 2 of the partitions in the temp dataset and replace the entire
+    // partitioned dataset. the partitions that weren't replaced in the final
+    // dataset should not exist either.
+
+    Assert.assertTrue("Should allow replacing a whole dataset",
+        partitioned.canReplace(partitioned));
+    Assert.assertTrue(
+        "Should not allow replacement test with a different dataset",
+        !partitioned.canReplace(temporary));
+
+    // delete the odd partition numbers
+    FileSystem local = LocalFileSystem.getInstance();
+    local.delete(
+        new Path(temporary.getDirectory(), "id_hash=1"),
+        true /* recursive */);
+    local.delete(
+        new Path(temporary.getDirectory(), "id_hash=3"),
+        true /* recursive */);
+    // also delete a partition that will be replaced in the partitioned dataset
+    local.delete(
+        new Path(partitioned.getDirectory(), "id_hash=2"),
+        true /* recursive */);
+
+    Set<String> originalFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Set<String> replacementFiles = Sets.newHashSet(
+        Iterators.transform(temporary.pathIterator(), new GetFilename()));
+    Assert.assertFalse("Sanity check", originalFiles.equals(replacementFiles));
+
+    partitioned.replace(partitioned, temporary);
+
+    Set<String> replacedFiles = Sets.newHashSet(
+        Iterators.transform(partitioned.pathIterator(), new GetFilename()));
+    Assert.assertEquals("Should contain the only the replacement files",
+        replacementFiles, replacedFiles);
+    Assert.assertEquals("Should have only 2 files (1 in each partition)",
+        2, replacedFiles.size());
+  }
+
   private static class GetFilename implements Function<Path, String> {
     @Override
     public String apply(Path path) {
diff --git a/kite-data/kite-data-mapreduce/src/main/java/org/kitesdk/data/mapreduce/DatasetKeyOutputFormat.java b/kite-data/kite-data-mapreduce/src/main/java/org/kitesdk/data/mapreduce/DatasetKeyOutputFormat.java
index 637c972..3963d13 100644
--- a/kite-data/kite-data-mapreduce/src/main/java/org/kitesdk/data/mapreduce/DatasetKeyOutputFormat.java
+++ b/kite-data/kite-data-mapreduce/src/main/java/org/kitesdk/data/mapreduce/DatasetKeyOutputFormat.java
@@ -40,6 +40,7 @@ import org.kitesdk.data.Datasets;
 import org.kitesdk.data.PartitionStrategy;
 import org.kitesdk.data.Signalable;
 import org.kitesdk.data.TypeNotFoundException;
+import org.kitesdk.data.ValidationException;
 import org.kitesdk.data.View;
 import org.kitesdk.data.spi.AbstractDataset;
 import org.kitesdk.data.spi.Compatibility;
@@ -72,7 +73,7 @@ public class DatasetKeyOutputFormat<E> extends OutputFormat<E, Void> {
   public static final String KITE_TYPE = "kite.outputEntityType";
   public static final String KITE_WRITE_MODE = "kite.outputMode";
 
-  public static enum WriteMode {
+  public enum WriteMode {
     DEFAULT, APPEND, OVERWRITE
   }
 
@@ -384,7 +385,7 @@ public class DatasetKeyOutputFormat<E> extends OutputFormat<E, Void> {
       Dataset<E> jobDataset = repo.load(TEMP_NAMESPACE, jobDatasetName);
       WriteMode mode = conf.getEnum(KITE_WRITE_MODE, WriteMode.DEFAULT);
       if (mode == WriteMode.OVERWRITE && canReplace(targetView)) {
-        ((Replaceable<Dataset<E>>) targetView.getDataset()).replace(jobDataset);
+        ((Replaceable<View<E>>) targetView.getDataset()).replace(targetView, jobDataset);
       } else {
         ((Mergeable<Dataset<E>>) targetView.getDataset()).merge(jobDataset);
       }
-- 
1.7.0.4

