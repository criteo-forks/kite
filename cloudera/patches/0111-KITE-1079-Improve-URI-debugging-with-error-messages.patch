From da1ae20d55bd464e2fb7cec5504790bb336f5268 Mon Sep 17 00:00:00 2001
From: Ryan Blue <blue@apache.org>
Date: Wed, 23 Sep 2015 16:28:14 -0700
Subject: [PATCH 111/140] KITE-1079: Improve URI debugging with error
 messages.

This adds a map to DynConstructor.Builder that keeps all of the reasons
why classes weren't loaded. In the case where one is present but can't
be loaded because a dependency is missing, it is obvious what needs to
be added to the classpath.
---
 .../java/org/kitesdk/compat/DynConstructors.java   |   50 ++++++++++++++++++--
 1 file changed, 47 insertions(+), 3 deletions(-)

diff --git a/kite-hadoop-compatibility/src/main/java/org/kitesdk/compat/DynConstructors.java b/kite-hadoop-compatibility/src/main/java/org/kitesdk/compat/DynConstructors.java
index 92e5dc1..371fcb8 100644
--- a/kite-hadoop-compatibility/src/main/java/org/kitesdk/compat/DynConstructors.java
+++ b/kite-hadoop-compatibility/src/main/java/org/kitesdk/compat/DynConstructors.java
@@ -19,10 +19,13 @@ package org.kitesdk.compat;
 import com.google.common.base.Objects;
 import com.google.common.base.Preconditions;
 import com.google.common.base.Throwables;
+import com.google.common.collect.Maps;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
+import java.util.Arrays;
+import java.util.Map;
 
 public class DynConstructors {
   public static class Ctor<C> extends DynMethods.UnboundMethod {
@@ -96,6 +99,7 @@ public class DynConstructors {
     private final Class<?> baseClass;
     private ClassLoader loader = Thread.currentThread().getContextClassLoader();
     private Ctor ctor = null;
+    private Map<String, Throwable> problems = Maps.newHashMap();
 
     public Builder(Class<?> baseClass) {
       this.baseClass = baseClass;
@@ -134,8 +138,10 @@ public class DynConstructors {
         impl(targetClass, types);
       } catch (NoClassDefFoundError e) {
         // cannot load this implementation
+        problems.put(className, e);
       } catch (ClassNotFoundException e) {
         // not the right implementation
+        problems.put(className, e);
       }
       return this;
     }
@@ -150,6 +156,7 @@ public class DynConstructors {
         ctor = new Ctor<T>(targetClass.getConstructor(types), targetClass);
       } catch (NoSuchMethodException e) {
         // not the right implementation
+        problems.put(methodName(targetClass, types), e);
       }
       return this;
     }
@@ -171,8 +178,10 @@ public class DynConstructors {
         hiddenImpl(targetClass, types);
       } catch (NoClassDefFoundError e) {
         // cannot load this implementation
+        problems.put(className, e);
       } catch (ClassNotFoundException e) {
         // not the right implementation
+        problems.put(className, e);
       }
       return this;
     }
@@ -189,8 +198,10 @@ public class DynConstructors {
         ctor = new Ctor<T>(hidden, targetClass);
       } catch (SecurityException e) {
         // unusable
+        problems.put(methodName(targetClass, types), e);
       } catch (NoSuchMethodException e) {
         // not the right implementation
+        problems.put(methodName(targetClass, types), e);
       }
       return this;
     }
@@ -200,8 +211,8 @@ public class DynConstructors {
       if (ctor != null) {
         return ctor;
       }
-      throw new NoSuchMethodException(
-          "Cannot find constructor for " + baseClass);
+      throw new NoSuchMethodException("Cannot find constructor for " +
+          baseClass + "\n" + formatProblems(problems));
     }
 
     @SuppressWarnings("unchecked")
@@ -209,7 +220,8 @@ public class DynConstructors {
       if (ctor != null) {
         return ctor;
       }
-      throw new RuntimeException("Cannot find constructor for " + baseClass);
+      throw new RuntimeException("Cannot find constructor for " +
+          baseClass + "\n" + formatProblems(problems));
     }
   }
 
@@ -226,4 +238,36 @@ public class DynConstructors {
       return null;
     }
   }
+
+  private static String formatProblems(Map<String, Throwable> problems) {
+    StringBuilder sb = new StringBuilder();
+    boolean first = true;
+    for (Map.Entry<String, Throwable> problem : problems.entrySet()) {
+      if (first) {
+        first = false;
+      } else {
+        sb.append("\n");
+      }
+      sb.append("\tMissing ").append(problem.getKey()).append(" [")
+          .append(problem.getValue().getClass().getName()).append(": ")
+          .append(problem.getValue().getMessage()).append("]");
+    }
+    return sb.toString();
+  }
+
+  private static String methodName(Class<?> targetClass, Class<?>... types) {
+    StringBuilder sb = new StringBuilder();
+    sb.append(targetClass.getName()).append("(");
+    boolean first = true;
+    for (Class<?> type : types) {
+      if (first) {
+        first = false;
+      } else {
+        sb.append(",");
+      }
+      sb.append(type.getName());
+    }
+    sb.append(")");
+    return sb.toString();
+  }
 }
-- 
1.7.9.5

