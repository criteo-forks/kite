From 4e3990e2b5b5216b9e62b56977cb31661ffd2c1c Mon Sep 17 00:00:00 2001
From: Wolfgang Hoschek <whoschek@cloudera.com>
Date: Mon, 1 Feb 2016 10:46:13 -0800
Subject: [PATCH 118/140] KITE-1108: Add optional retry feature to loadSolr
 morphline command

---
 .../resources/test-morphlines/loadSolrBasic.conf   |   18 +
 .../solrj/retry/DefaultRetryPolicyFactory.java     |   68 +++
 .../FlexibleBoundedExponentialBackoffRetry.java    |  121 ++++
 .../solr/client/solrj/retry/MetricsFacade.java     |   58 ++
 .../solr/client/solrj/retry/MutableLong.java       |   40 ++
 .../solrj/retry/RetriesExhaustedException.java     |   61 ++
 .../solr/client/solrj/retry/RetryPolicy.java       |   41 ++
 .../client/solrj/retry/RetryPolicyFactory.java     |   57 ++
 .../solr/client/solrj/retry/RetrySleeper.java      |   37 ++
 .../client/solrj/retry/RetryingSolrServer.java     |  362 +++++++++++
 .../kitesdk/morphline/solr/LoadSolrBuilder.java    |   64 +-
 .../org/kitesdk/morphline/solr/RateLimiter.java    |  633 ++++++++++++++++++++
 .../morphline/solr/RetryPolicyFactoryParser.java   |   57 ++
 .../kitesdk/morphline/solr/SmoothRateLimiter.java  |  397 ++++++++++++
 .../org/kitesdk/morphline/solr/SolrLocator.java    |   11 +
 .../morphline/solr/SolrServerDocumentLoader.java   |   26 +-
 ...FlexibleBoundedExponentialBackoffRetryTest.java |  122 ++++
 .../client/solrj/retry/RetryingSolrServerTest.java |  396 ++++++++++++
 18 files changed, 2562 insertions(+), 7 deletions(-)
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/DefaultRetryPolicyFactory.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetry.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MetricsFacade.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MutableLong.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetriesExhaustedException.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicy.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicyFactory.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetrySleeper.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryingSolrServer.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RateLimiter.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RetryPolicyFactoryParser.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SmoothRateLimiter.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetryTest.java
 create mode 100644 kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/RetryingSolrServerTest.java

diff --git a/kite-morphlines/kite-morphlines-core/src/test/resources/test-morphlines/loadSolrBasic.conf b/kite-morphlines/kite-morphlines-core/src/test/resources/test-morphlines/loadSolrBasic.conf
index d4a84a0..0e86fdb 100644
--- a/kite-morphlines/kite-morphlines-core/src/test/resources/test-morphlines/loadSolrBasic.conf
+++ b/kite-morphlines/kite-morphlines-core/src/test/resources/test-morphlines/loadSolrBasic.conf
@@ -39,6 +39,12 @@ SOLR_LOCATOR : {
 }
 SOLR_LOCATOR : ${?ENV_SOLR_LOCATOR}
 
+maxRecordsPerSecond : 100000000
+retryPolicy_baseSleepTime : "1001 milliseconds"
+retryPolicy_maxSleepTime : "10 seconds"
+retryPolicy_maxRetries : 100
+retryPolicy_maxElapsedTime : "3 minutes"
+
 morphlines : [
   {
     id : morphline1
@@ -57,6 +63,18 @@ morphlines : [
           boosts : {
             id : 1.0
           }
+          maxRecordsPerSecond: ${maxRecordsPerSecond} # if absent then defaults to unlimited
+          
+          # if retryPolicy is absent then default to same as perfkit unless system property loadSolr.disableRetryPolicy=true (which in turn is absent by default)
+          retryPolicy : {
+            BoundedExponentialBackoffRetry {
+              baseSleepTime : ${retryPolicy_baseSleepTime}
+              maxSleepTime : ${retryPolicy_maxSleepTime}
+              maxRetries : ${retryPolicy_maxRetries}
+              maxElapsedTime : ${retryPolicy_maxElapsedTime}
+            }
+          }
+          
         }
       }
        
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/DefaultRetryPolicyFactory.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/DefaultRetryPolicyFactory.java
new file mode 100644
index 0000000..277a1d8
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/DefaultRetryPolicyFactory.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.util.concurrent.TimeUnit;
+
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.SolrException.ErrorCode;
+
+/**
+ * A RetryPolicyFactory that's suitable for many Solr apps with idempotent request semantics.
+ */
+public final class DefaultRetryPolicyFactory implements RetryPolicyFactory {
+
+  private final RetryPolicy initialRetryPolicy;
+  
+  public DefaultRetryPolicyFactory() {
+    this(
+      new FlexibleBoundedExponentialBackoffRetry(
+        TimeUnit.MILLISECONDS.toNanos(125), 
+        TimeUnit.SECONDS.toNanos(10),
+        100, 
+        TimeUnit.MINUTES.toNanos(3)));
+  }
+  
+  /**
+   * Caution: initialRetryPolicy must be thread-safe if multiple threads are concurrently calling
+   * the same RetryingSolrServer.
+   */
+  public DefaultRetryPolicyFactory(RetryPolicy initialRetryPolicy) {
+    this.initialRetryPolicy = initialRetryPolicy;
+  }
+  
+  @Override
+  public RetryPolicy getRetryPolicy(Throwable exception, SolrRequest request, SolrServer server,
+      RetryPolicy currentPolicy) {
+    if (exception instanceof SolrException) {
+      SolrException sex = (SolrException) exception;
+      if (sex.code() == ErrorCode.UNAUTHORIZED.code) {
+        return RetryPolicyFactory.DONT_RETRY; // no point retrying that - would never succeed
+      }
+      if (sex.code() == ErrorCode.UNSUPPORTED_MEDIA_TYPE.code) {
+        return RetryPolicyFactory.DONT_RETRY; // no point retrying that - would never succeed
+      }
+    }
+    if (currentPolicy == null) {
+      return initialRetryPolicy; // init
+    } else {
+      return currentPolicy; // continue with current policy
+    }
+  }
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetry.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetry.java
new file mode 100644
index 0000000..cbc563e
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetry.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.math.RoundingMode;
+import java.util.concurrent.ThreadLocalRandom;
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.base.Preconditions;
+import com.google.common.math.LongMath;
+
+/**
+ * A retry policy that retries with exponentially increasing sleep time between retries until it has
+ * reached either a) the given max number of retries or b) more than the given amount of 
+ * time has elapsed since the start of the operation, whichever occurs first.
+ * 
+ * For example, with baseSleepTime=100, maxSleepTime=1000 we sleep as follows in each iteration:
+ * random(100..199), random(200..399), random(400..799), min(random(800..1599), 1000), 1000, 1000,
+ * ... and so on.
+ * 
+ * This implementation is thread-safe.
+ */
+public final class FlexibleBoundedExponentialBackoffRetry implements RetryPolicy {
+
+  private final int maxRetries;
+  private final long baseSleepTimeNanos;
+  private final long maxSleepTimeNanos;
+  private final long maxElapsedTimeNanos;
+  private final long retriesLimit;
+
+  /**
+   * @param baseSleepTimeNanos
+   *          initial amount of time to wait between retries
+   * @param maxSleepTimeNanos
+   *          max time in nanos to sleep on each retry
+   * @param maxRetries
+   *          max number of times to retry
+   * @param maxElapsedTimeNanos
+   *          max time in nanos to spend across all retries
+   */
+  public FlexibleBoundedExponentialBackoffRetry(
+      long baseSleepTimeNanos, 
+      long maxSleepTimeNanos, 
+      int maxRetries,
+      long maxElapsedTimeNanos) {
+    
+    Preconditions.checkArgument(baseSleepTimeNanos >= 0, 
+        "baseSleepTimeNanos must not be negative: %s", baseSleepTimeNanos);
+    Preconditions.checkArgument(maxSleepTimeNanos >= baseSleepTimeNanos,
+        "maxSleepNanos: %s must not be less than baseSleepTimeNanos: %s", 
+        maxSleepTimeNanos, baseSleepTimeNanos);
+    Preconditions.checkArgument(maxRetries >= 0, 
+        "maxRetries must not be negative: %s", maxRetries);
+    Preconditions.checkArgument(maxElapsedTimeNanos >= 0, 
+        "maxElapsedTimeNanos must not be negative: %s", maxElapsedTimeNanos);
+    
+    baseSleepTimeNanos = Math.max(1, baseSleepTimeNanos);
+    this.baseSleepTimeNanos = baseSleepTimeNanos;
+    this.maxSleepTimeNanos = maxSleepTimeNanos;
+    this.maxRetries = maxRetries;
+    this.maxElapsedTimeNanos = maxElapsedTimeNanos;
+    this.retriesLimit = LongMath.log2(
+        Long.MAX_VALUE / baseSleepTimeNanos, RoundingMode.DOWN) - 2;
+  }
+
+  @Override
+  public boolean allowRetry(int retryCount, long elapsedTimeNanos, RetrySleeper sleeper) {
+    if (retryCount >= 0 && 
+        retryCount < maxRetries && 
+        elapsedTimeNanos < maxElapsedTimeNanos) {
+      try {
+        sleeper.sleepFor(getSleepTime(retryCount), TimeUnit.NANOSECONDS);
+      } catch (InterruptedException e) {
+        Thread.currentThread().interrupt();
+        return false;
+      }
+      return true;
+    }
+    return false;
+  }
+  
+  private long getSleepTime(int retryCount) {
+    if (retryCount < retriesLimit) {
+      long low = baseSleepTimeNanos * (1L << retryCount);
+      long high = 2 * low;
+      long sleepTimeNanos = ThreadLocalRandom.current().nextLong(low, high);
+      return Math.min(maxSleepTimeNanos, sleepTimeNanos);
+    } else {
+      return maxSleepTimeNanos;
+    }
+  }
+  
+  @Override
+  public String toString() {
+    return String.format(
+        "baseSleepTime[secs]:%1.1f, maxSleepTime[secs]:%1.1f, maxRetries:%d, "
+        + "maxElapsedTime[secs]:%1.1f",
+        toSeconds(baseSleepTimeNanos), 
+        toSeconds(maxSleepTimeNanos), 
+        maxRetries, 
+        toSeconds(maxElapsedTimeNanos));
+  }
+  
+  private double toSeconds(long nanos) {
+    return nanos / (1000.0 * 1000 * 1000);
+  }
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MetricsFacade.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MetricsFacade.java
new file mode 100644
index 0000000..ce58d3f
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MetricsFacade.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Simple facade in front of a real metrics aggregation implementation such as codahale metrics or
+ * similar.
+ */
+public interface MetricsFacade {
+
+  /**
+   * Increments the meter by <code>increment</code>.
+   *
+   * @param name
+   *          the name of the meter to update
+   * @param increment
+   *          the amount by which the meter shall be incremented
+   */
+  void markMeter(String name, long increment);
+
+  /**
+   * Adds the given numeric value to a histogram.
+   *
+   * @param name
+   *          the name of the histogram to update
+   * @param value
+   *          the numeric value to add to the histogram
+   */
+  void updateHistogram(String name, long value);
+
+  /**
+   * Adds the given duration to a timer.
+   *
+   * @param name
+   *          the name of the timer to update
+   * @param duration
+   *          the length of the duration to add to the timer
+   * @param unit
+   *          the time unit of the <code>duration</code>
+   */
+  void updateTimer(String name, long duration, TimeUnit unit);
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MutableLong.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MutableLong.java
new file mode 100644
index 0000000..bf863ea
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/MutableLong.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+/** Holder for a mutable long integer value */
+final class MutableLong {
+
+  private long value;
+
+  public MutableLong(long value) {
+    this.value = value;
+  }
+
+  public long get() {
+    return value;
+  }
+
+  public void inc(long value) {
+    this.value += value;
+  }
+
+  @Override
+  public String toString() {
+    return String.valueOf(value);
+  }
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetriesExhaustedException.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetriesExhaustedException.java
new file mode 100644
index 0000000..ec3afc5
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetriesExhaustedException.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+import org.apache.solr.client.solrj.SolrServerException;
+
+/**
+ * Exception thrown by {@link RetryingSolrServer} when an attempt to perform a solrj request (e.g.
+ * update, delete, query, commit) fails after a bunch of retries.
+ */
+public final class RetriesExhaustedException extends SolrServerException {
+
+  RetriesExhaustedException(String msg, Map<String, MutableLong> counters, Throwable cause) {
+    super(msg + getRootCauseCountersAsString(counters), cause);        
+  }
+  
+  private static String getRootCauseCountersAsString(Map<String, MutableLong> counters) {
+    // print sorted descending by numOccurances for human readability
+    List<Map.Entry<String, MutableLong>> entries = 
+        new ArrayList<Map.Entry<String, MutableLong>>(counters.entrySet());
+    Collections.sort(entries, new Comparator<Map.Entry<String, MutableLong>>() {
+      @Override
+      public int compare(Entry<String, MutableLong> o1, Entry<String, MutableLong> o2) {
+        return (int) (o2.getValue().get() - o1.getValue().get());
+      }
+    });
+    
+    StringBuilder rootCauses = new StringBuilder();
+    for (Map.Entry<String, MutableLong> entry : entries) {
+      if (rootCauses.length() > 0) {
+        rootCauses.append(", ");
+      }
+      rootCauses.append(entry.getKey());
+      rootCauses.append(": Occurred ");
+      rootCauses.append(entry.getValue());
+      rootCauses.append(" times");
+    }
+    return rootCauses.toString();
+  }
+  
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicy.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicy.java
new file mode 100644
index 0000000..06e1a13
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicy.java
@@ -0,0 +1,41 @@
+// copied from Apache curator-2.7.1
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+/**
+ * Abstracts the policy to use when retrying connections
+ */
+public interface RetryPolicy {
+  
+  /**
+   * Called when an operation has failed for some reason. This method should return true to make
+   * another attempt.
+   *
+   *
+   * @param retryCount
+   *          the number of times retried so far (0 the first time)
+   * @param elapsedTimeNanos
+   *          the relative elapsed time in nanos since the operation was attempted
+   * @param sleeper
+   *          use this to sleep - DO NOT call Thread.sleep
+   * @return true/false
+   */
+  public boolean allowRetry(int retryCount, long elapsedTimeNanos, RetrySleeper sleeper);
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicyFactory.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicyFactory.java
new file mode 100644
index 0000000..7bc501e
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryPolicyFactory.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+
+/**
+ * Pluggable API to enable users to specify exactly what kind of exceptions for what kind of solrj
+ * requests shall be retried how and for how long.
+ */
+public interface RetryPolicyFactory {
+  
+  /** A retry policy that does not retry requests; Same as <code>null</code>. */
+  public static final RetryPolicy DONT_RETRY = null;
+
+  /**
+   * Returns a retry policy object if the given solrj request is retryable for the given exception
+   * for the given Solr server. Otherwise returns <code>null</code>, indicating that this request
+   * shall not be retried, and that instead the exception shall be rethrown.
+   * 
+   * @param exception
+   *          The exception thrown on attempting to perform the request
+   * @param request
+   *          The solrj request that was attempted
+   * @param solrServer
+   *          The solrj client proxy object that attempted to perform the request; Talks over the
+   *          network to a Solr server.
+   * @param currentPolicy
+   *          The retry policy that has been in effect on the previous attempt to perform the
+   *          request. This parameter is <code>null</code> on the first request attempt, and
+   *          subsequently it is the value returned by the previous call to this method for this
+   *          particular request. This parameter is guaranteed to be non-null on subsequent attempts
+   *          for this particular request.
+   * @return The new retry policy to use when retrying this request, or <code>null</code> if this
+   *         request shall not be retried.
+   */
+  public RetryPolicy getRetryPolicy(
+      Throwable exception, 
+      SolrRequest request, 
+      SolrServer solrServer,
+      RetryPolicy currentPolicy);
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetrySleeper.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetrySleeper.java
new file mode 100644
index 0000000..c71ddf5
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetrySleeper.java
@@ -0,0 +1,37 @@
+// copied from Apache curator-2.7.1
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.util.concurrent.TimeUnit;
+
+/**
+ * Abstraction for retry policies to sleep
+ */
+public interface RetrySleeper
+{
+    /**
+     * Sleep for the given time
+     *
+     * @param time time
+     * @param unit time unit
+     * @throws InterruptedException if the sleep is interrupted
+     */
+    public void sleepFor(long time, TimeUnit unit) throws InterruptedException;
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryingSolrServer.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryingSolrServer.java
new file mode 100644
index 0000000..2e719cd
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/apache/solr/client/solrj/retry/RetryingSolrServer.java
@@ -0,0 +1,362 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.regex.Pattern;
+
+import org.apache.commons.lang.exception.ExceptionUtils;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
+import org.apache.solr.client.solrj.request.QueryRequest;
+import org.apache.solr.common.util.NamedList;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.annotations.VisibleForTesting;
+
+
+/**
+ * A wrapper around an underlying solrj {@link SolrServer} object; On exceptions, the wrapper
+ * retries solrj requests according to the given {@link RetryPolicyFactory}.
+ */
+public class RetryingSolrServer extends SolrServer {
+
+  private final SolrServer solrServer;
+  
+  private final RetryPolicyFactory retryPolicyFactory;
+
+  private final MetricsFacade metrics;
+
+  private final CountDownLatch isShuttingDown = new CountDownLatch(1);
+  
+  private final RetrySleeper sleeper = new RetrySleeper() {
+    @Override
+    public void sleepFor(long time, TimeUnit unit) throws InterruptedException {
+      isShuttingDown.await(time, unit);
+    }
+  };
+  
+  private final AtomicLong totalRetryCount = new AtomicLong(0);
+  
+  private final AtomicLong totalRequestCount = new AtomicLong(0);
+  
+  private static final String ROOT_PREFIX = RetryingSolrServer.class.getSimpleName() + ".";
+
+  private static final int MAX_STRING_LENGTH = Integer.parseInt(System.getProperty(
+      RetryingSolrServer.class.getSimpleName() +".maxStringLength", "300"));
+  
+  private static final boolean REDACT_QUERY_REQUEST_PARAMS = "true".equals(System.getProperty(
+      RetryingSolrServer.class.getSimpleName() +".redactQueryRequestParams", "true"));
+
+  private static final boolean ENABLE_LOGGING = "true".equals(System.getProperty(
+      RetryingSolrServer.class.getSimpleName() +".enableLogging", "true"));
+
+  private static final Pattern WHITESPACE_EXCEPT_SPACE_PATTERN = Pattern.compile(
+      "[\\t\\n\\x0B\\f\\r]");
+  
+  private static final Pattern TWO_OR_MORE_SPACES_PATTERN = Pattern.compile(
+      "  +"); // two or more spaces
+
+  private static final Pattern EXCEPTION_HOST_PATTERN = Pattern.compile(
+      "(UnknownHostException: )([0-9A-Za-z][0-9A-Za-z-]{0,62})((?:\\.[0-9A-Za-z][0-9A-Za-z-]{0,62}){2,}?)");
+
+  // Note: %3A%2F%2F is an encoding of :// used in some Solr exception messages
+  private static final Pattern URL_SCHEME_AND_AUTHORITY_PATTERN = Pattern.compile(
+      "([A-Za-z][0-9A-Za-z+-.]{0,62}(?:://|%3A%2F%2F))([0-9A-Za-z][0-9A-Za-z-]{0,62})((?:\\.[0-9A-Za-z][0-9A-Za-z-]{0,62})*)");
+  
+  private static final Pattern SHARD_AND_REPLICA_PATTERN = Pattern.compile(
+      "(_(?:shard|SHARD))[0-9]+(_(?:replica|REPLICA))[0-9]+");
+
+  private static final Pattern COLLECTION_AND_SLICE_PATTERN = Pattern.compile(
+      "(collection: \\S+ slice: shard)\\d+");
+
+  private static final Pattern NOW_TIMESTAMP_PATTERN = Pattern.compile(
+      "(NOW=)\\d+"); // part of Solr query params
+
+  private static final Logger LOG = LoggerFactory.getLogger(RetryingSolrServer.class);
+    
+  /**
+   * Constructs an instance with the given parameters.
+   *
+   * Caution: retryPolicyFactory and metrics params must be thread-safe if multiple threads are
+   * concurrently calling the same {@link RetryingSolrServer}.
+   */
+  public RetryingSolrServer(SolrServer solrServer, 
+                            RetryPolicyFactory retryPolicyFactory, 
+                            MetricsFacade metrics) {
+    if (solrServer == null) {
+      throw new IllegalArgumentException("solrServer param must not be null");
+    }
+    this.solrServer = solrServer;
+    if (retryPolicyFactory == null) {
+      throw new IllegalArgumentException("retryPolicyFactory param must not be null");
+    }
+    this.retryPolicyFactory = retryPolicyFactory;
+    if (metrics == null) {
+      throw new IllegalArgumentException("metrics param must not be null");
+    }
+    this.metrics = metrics;
+  }
+
+  /** Returns the backing solr proxy */
+  public final SolrServer getUnderlyingSolrServer() {
+    return solrServer;
+  }
+  
+  protected final MetricsFacade getMetrics() {
+    return metrics;
+  }
+  
+  /**
+   * Returns the number of nano seconds to wait until starting execution of this request. This
+   * default implementation returns zero to indicate that the request shall be started immediately.
+   * 
+   * Override this method for custom behaviour, e.g. using Guava's RateLimiter.reserve(1).
+   */
+  protected long limitRequestRate(SolrRequest request) {
+    return 0;
+  }
+
+  @Override
+  public NamedList<Object> request(final SolrRequest request) throws SolrServerException, IOException {
+    int retryCount = 0;
+    RetryPolicy retryPolicy = null;
+    totalRequestCount.incrementAndGet();
+    getMetrics().markMeter(ROOT_PREFIX + "requests", 1);
+    Map<String, MutableLong> exceptionRootCauseCounters = new HashMap<String, MutableLong>();
+    final long startTime = System.nanoTime();
+    while (true) {
+      final long nanosToWaitForRateLimiter = limitRequestRate(request);
+      try {
+        isShuttingDown.await(nanosToWaitForRateLimiter, TimeUnit.NANOSECONDS);
+      } catch (InterruptedException e) {
+        ; // ignore
+      }
+
+      final long lastStartTime = System.nanoTime();
+      NamedList response;
+      try {
+        response = solrServer.request(request);
+      } catch (Exception exception) {
+        long requestDuration = System.nanoTime() - lastStartTime;
+        String exceptionTopLevelMsg = limitStringLength(getExceptionKey(exception));
+        String exceptionRootCauseMsg = limitStringLength(getExceptionKey(getRootCause(exception)));
+        String requestKey = limitStringLength(getRequestKey(request));
+        handleException(request, exceptionTopLevelMsg, exceptionRootCauseMsg, requestKey, requestDuration);
+        String reason = "n/a";
+        boolean retry = !isShuttingDown();
+        if (!retry) {
+          reason = "Solrj client is shutting down";
+        } else {
+          retryPolicy = retryPolicyFactory.getRetryPolicy(exception, request, solrServer, retryPolicy);
+          retry = retryPolicy != null;
+          if (!retry) {
+            reason = "Exception is non-retryable per RetryPolicyFactory {" + retryPolicyFactory + "}";
+          } else {
+            if (ENABLE_LOGGING) {
+              LOG.warn("Retryable exception received: ", exception);
+            }            
+            retry = retryPolicy.allowRetry(
+                retryCount, 
+                System.nanoTime() - startTime, 
+                sleeper);
+            if (!retry) {
+              reason = "Request must not be retried " + (retryCount > 0 ? "anymore " : "") 
+                     + "per RetryPolicy {" + retryPolicy + "}";
+            } else {
+              retry = !isShuttingDown(); // recheck
+              if (!retry) {
+                reason = "Solrj client is shutting down(2)";
+              }
+            }
+          }
+        }
+        
+        if (!retry) {
+          // rethrow exception with added details to help users diagnose the situation
+          long secs = TimeUnit.NANOSECONDS.toSeconds(System.nanoTime() - startTime);
+          throw new RetriesExhaustedException(
+              "Performed " + totalRetryCount + " retries across " + totalRequestCount
+              + " client requests. Gave up because the last " + retryCount + " retries across " + secs
+              + " seconds for the current request failed with this reason: '" + reason + "' and these"
+              + " root causes: ",
+              exceptionRootCauseCounters, 
+              exception);
+        } 
+        
+        if (ENABLE_LOGGING) {
+          LOG.info("Retrying request: {}", requestKey);
+        }
+        assert exception != null;
+        retryCount++;
+        totalRetryCount.incrementAndGet();
+        incCounter(exceptionRootCauseCounters, exceptionRootCauseMsg);
+        metrics.markMeter(ROOT_PREFIX + "retries", 1);
+        continue; // retry request by continuing while(true) retry loop
+      }
+      
+      // solr request succeeded without throwing an exception 
+      long requestDuration = System.nanoTime() - lastStartTime;
+      handleSuccess(request, response, retryCount, startTime, requestDuration);
+      return response;
+    }
+  }
+
+  private void handleSuccess(SolrRequest request, NamedList response, int retryCount, long startTime,
+      long requestDuration) {
+    String successPrefix = ROOT_PREFIX + "success.";
+    if (retryCount > 0) {
+      String retriedRequestsPrefix = successPrefix + "retry.";
+      long totalRequestDuration = System.nanoTime() - startTime;
+      metrics.updateHistogram(retriedRequestsPrefix + "count", retryCount);
+      metrics.updateTimer(retriedRequestsPrefix + "time", totalRequestDuration, TimeUnit.NANOSECONDS);
+//    metrics.updateHistogram(retriedRequestsPrefix + "count.req." + requestKey, retryCount);
+//    metrics.updateHistogram(retriedRequestsPrefix + "count.top." + firstExceptionTopLevelMsg, retryCount);
+//    metrics.updateHistogram(retriedRequestsPrefix + "count.root." + firstExceptionRootCauseMsg, retryCount);
+//    metrics.updateTimer(retriedRequestsPrefix + "time.req." + requestKey, totalRequestDuration, TimeUnit.NANOSECONDS);
+//    metrics.updateTimer(retriedRequestsPrefix + "time.top." + firstExceptionTopLevelMsg, totalRequestDuration, TimeUnit.NANOSECONDS);
+//    metrics.updateTimer(retriedRequestsPrefix + "time.root." + firstExceptionRootCauseMsg, totalRequestDuration, TimeUnit.NANOSECONDS);
+    }
+    metrics.updateHistogram(successPrefix + "anycount", retryCount);
+    metrics.updateTimer(ROOT_PREFIX + "time", requestDuration, TimeUnit.NANOSECONDS);
+  }
+
+  private void handleException(SolrRequest request, String exceptionTopLevelMsg, String exceptionRootCauseMsg,
+      String requestKey, long requestDuration) {
+    String timePrefix = "time.";
+    metrics.updateTimer(ROOT_PREFIX + "time", requestDuration, TimeUnit.NANOSECONDS);
+    String failedRequestsPrefix = ROOT_PREFIX + "fail.";
+    metrics.updateTimer(failedRequestsPrefix + "time", requestDuration, TimeUnit.NANOSECONDS);
+    metrics.updateTimer(failedRequestsPrefix + timePrefix + "req." + requestKey, requestDuration, TimeUnit.NANOSECONDS);
+    metrics.updateTimer(failedRequestsPrefix + timePrefix + "xreq.top." + requestKey + "." + exceptionTopLevelMsg, requestDuration, TimeUnit.NANOSECONDS);
+    metrics.updateTimer(failedRequestsPrefix + timePrefix + "xreq.root." + requestKey + "." + exceptionRootCauseMsg, requestDuration, TimeUnit.NANOSECONDS);
+    metrics.updateTimer(failedRequestsPrefix + timePrefix + "top." + exceptionTopLevelMsg, requestDuration, TimeUnit.NANOSECONDS);
+    metrics.updateTimer(failedRequestsPrefix + timePrefix + "root." + exceptionRootCauseMsg, requestDuration, TimeUnit.NANOSECONDS);
+  }
+
+  protected String getRequestKey(SolrRequest request) {
+    String str = request.getClass().getSimpleName() + ".";
+    return REDACT_QUERY_REQUEST_PARAMS  && request instanceof QueryRequest ? 
+      str + "<redacted>" : 
+      str + normalizeRequestKey(String.valueOf(request.getParams()));
+  }
+
+  @VisibleForTesting
+  final String normalizeRequestKey(String str) {
+    str = NOW_TIMESTAMP_PATTERN.matcher(str).replaceAll("$1<redacted>");
+    str = SHARD_AND_REPLICA_PATTERN.matcher(str).replaceAll("$1<redacted>$2<redacted>");
+    str = normalizeWhitespace(str);
+    return str;
+  }
+
+  /**
+   * Make metric names a bit more human readable.
+   * Examples:     
+   * "foo  bar" -> "foo bar"
+   * "foo\nbar" -> "foo bar"
+   * "foo\n\tbar" -> "foo bar"
+   */
+  private String normalizeWhitespace(String str) {
+    str = WHITESPACE_EXCEPT_SPACE_PATTERN.matcher(str).replaceAll(" ");
+    str = TWO_OR_MORE_SPACES_PATTERN.matcher(str).replaceAll(" ");
+    return str;
+  }
+  
+  protected String getExceptionKey(Throwable exception) {
+    return normalizeExceptionKey(exception.toString());
+  }
+  
+  /**
+   * Coalesce exception messages containing HTTP REST calls to all server shards into a single bucket.
+   * This greatly reduces the amount of metric spam.
+   * Example: https://vb0706.foo.bar.com:8983 --> https://<redacted>.foo.bar.com:8983
+   * Example: UnknownHostException: vb0706.foo.bar.com -> UnknownHostException: <redacted>.foo.bar.com
+   * Example: insertAndQueryTweets_shard30_replica91 --> insertAndQueryTweets_shard<redacted>_replica<redacted>
+   * Example: collection: collection1 slice: shard130 --> collection: collection1 slice: shard<redacted>
+   * Example: &NOW=1448689151133 -> &NOW=<redacted>
+   */
+  private String normalizeExceptionKey(String str) {
+    str = URL_SCHEME_AND_AUTHORITY_PATTERN.matcher(str).replaceAll("$1<redacted>$3");
+    str = SHARD_AND_REPLICA_PATTERN.matcher(str).replaceAll("$1<redacted>$2<redacted>");
+    str = EXCEPTION_HOST_PATTERN.matcher(str).replaceAll("$1<redacted>$3");
+    str = COLLECTION_AND_SLICE_PATTERN.matcher(str).replaceAll("$1<redacted>");
+    str = NOW_TIMESTAMP_PATTERN.matcher(str).replaceAll("$1<redacted>");
+    str = normalizeWhitespace(str);
+    str = omitPackageName(str, "java.io.");
+    str = omitPackageName(str, "java.net.");
+    str = omitPackageName(str, "org.apache.solr.client.solrj.impl.");
+    //str = omitPackageName(str, "org.apache.http.client.");    
+    return str;
+  }
+  
+  private String omitPackageName(String str, String prefix) {
+    return str.startsWith(prefix) ? str.substring(prefix.length()) : str;
+  }
+
+  /** prevents gigantic messages */
+  private String limitStringLength(String str) {
+    if (str.length() > MAX_STRING_LENGTH) {
+      str = str.substring(0, MAX_STRING_LENGTH) + " ..."; 
+    }
+    return str;
+  }
+
+  private void incCounter(Map<String, MutableLong> counters, String key) {
+    MutableLong counter = counters.get(key);
+    if (counter == null) {
+      counter = new MutableLong(0);
+      counters.put(key, counter);
+    }
+    counter.inc(1);
+  }
+
+  private Throwable getRootCause(Throwable throwable) {
+    Throwable rootCause = ExceptionUtils.getRootCause(throwable); 
+    if (rootCause != null) {
+      return rootCause;
+    } else {
+      return throwable;
+    }
+  }
+  
+  private boolean isShuttingDown() {
+    try {
+      return isShuttingDown.await(0, TimeUnit.NANOSECONDS);
+    } catch (InterruptedException e) {
+      return true;
+    }
+  }
+  
+  @Override
+  public DocumentObjectBinder getBinder() {
+    return solrServer.getBinder();
+  }
+
+  @Override
+  public void shutdown() {
+    isShuttingDown.countDown();
+    solrServer.shutdown();
+  }
+  
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/LoadSolrBuilder.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/LoadSolrBuilder.java
index fee95ea..0bc517a 100644
--- a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/LoadSolrBuilder.java
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/LoadSolrBuilder.java
@@ -21,8 +21,11 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.retry.MetricsFacade;
+import org.apache.solr.client.solrj.retry.RetryPolicyFactory;
 import org.apache.solr.common.SolrInputDocument;
 import org.kitesdk.morphline.api.Command;
 import org.kitesdk.morphline.api.CommandBuilder;
@@ -35,7 +38,9 @@ import org.kitesdk.morphline.base.Configs;
 import org.kitesdk.morphline.base.Metrics;
 import org.kitesdk.morphline.base.Notifications;
 
+import com.codahale.metrics.MetricRegistry;
 import com.codahale.metrics.Timer;
+import com.google.common.base.Preconditions;
 import com.typesafe.config.Config;
 import com.typesafe.config.ConfigFactory;
 
@@ -47,7 +52,10 @@ public final class LoadSolrBuilder implements CommandBuilder {
   public static final String SOLR_LOCATOR_PARAM = "solrLocator";
   public static final String LOAD_SOLR_DELETE_BY_ID = "_loadSolr_deleteById";
   public static final String LOAD_SOLR_DELETE_BY_QUERY = "_loadSolr_deleteByQuery";
-  public static final String LOAD_SOLR_CHILD_DOCUMENTS = "_loadSolr_childDocuments";  
+  public static final String LOAD_SOLR_CHILD_DOCUMENTS = "_loadSolr_childDocuments";
+  
+  private static final boolean DISABLE_RETRY_POLICY_BY_DEFAULT = Boolean.parseBoolean(System.getProperty(
+      LoadSolrBuilder.class.getName() + ".disableRetryPolicyByDefault", "false"));
 
   @Override
   public Collection<String> getNames() {
@@ -67,6 +75,7 @@ public final class LoadSolrBuilder implements CommandBuilder {
     
     private final DocumentLoader loader;
     private final Map<String, Float> boosts = new HashMap();
+    private final RateLimiter rateLimiter;
     private final Timer elapsedTime;    
     private final boolean isDryRun;
     
@@ -75,7 +84,9 @@ public final class LoadSolrBuilder implements CommandBuilder {
       Config solrLocatorConfig = getConfigs().getConfig(config, SOLR_LOCATOR_PARAM);
       SolrLocator locator = new SolrLocator(solrLocatorConfig, context);
       LOG.debug("solrLocator: {}", locator);
-      this.loader = locator.getLoader();
+      RetryPolicyFactory retryPolicyFactory = parseRetryPolicyFactory(
+          getConfigs().getConfig(config, "retryPolicy", null));
+      this.loader = locator.getLoader(retryPolicyFactory, new CodahaleMetricsFacade(context.getMetricRegistry()));
 
       Config boostsConfig = getConfigs().getConfig(config, "boosts", ConfigFactory.empty());
       for (Map.Entry<String, Object> entry : new Configs().getEntrySet(boostsConfig)) {
@@ -83,11 +94,25 @@ public final class LoadSolrBuilder implements CommandBuilder {
         float boost = Float.parseFloat(entry.getValue().toString().trim());
         boosts.put(fieldName, boost);
       }
+      this.rateLimiter = RateLimiter.create(getConfigs().getDouble(config, "maxRecordsPerSecond", Double.MAX_VALUE));
       this.isDryRun = context.getTypedSettings().getBoolean(TypedSettings.DRY_RUN_SETTING_NAME, false);
       validateArguments();
       this.elapsedTime = getTimer(Metrics.ELAPSED_TIME);
     }
 
+    private RetryPolicyFactory parseRetryPolicyFactory(Config retryPolicyConfig) {      
+      if (retryPolicyConfig == null && !DISABLE_RETRY_POLICY_BY_DEFAULT) {
+        // ask RetryPolicyFactoryParser to return a retry policy with reasonable defaults
+        retryPolicyConfig = ConfigFactory.parseString(
+            "{" + RetryPolicyFactoryParser.BOUNDED_EXPONENTIAL_BACKOFF_RETRY_NAME + "{}}");
+      }
+      if (retryPolicyConfig == null) {
+        return null;
+      } else {
+        return new RetryPolicyFactoryParser().parse(retryPolicyConfig);
+      }
+    }
+
     @Override
     protected void doNotify(Record notification) {
       for (Object event : Notifications.getLifecycleEvents(notification)) {
@@ -132,6 +157,7 @@ public final class LoadSolrBuilder implements CommandBuilder {
     
     @Override
     protected boolean doProcess(Record record) {
+      rateLimiter.acquire(); 
       Timer.Context timerContext = elapsedTime.time();
       List deleteById = record.get(LOAD_SOLR_DELETE_BY_ID);
       List deleteByQuery = record.get(LOAD_SOLR_DELETE_BY_QUERY);
@@ -211,4 +237,38 @@ public final class LoadSolrBuilder implements CommandBuilder {
     }
     
   }
+  
+  
+  ///////////////////////////////////////////////////////////////////////////////
+  // Nested classes:
+  ///////////////////////////////////////////////////////////////////////////////
+  /**
+   * A facade using codahale metrics as a backend.
+   */
+  private static final class CodahaleMetricsFacade implements MetricsFacade {
+    
+    private final MetricRegistry registry;
+
+    public CodahaleMetricsFacade(MetricRegistry registry) {
+      Preconditions.checkNotNull(registry);
+      this.registry = registry;
+    }
+    
+    @Override
+    public void markMeter(String name, long increment) {
+      registry.meter(name).mark(increment);
+    }
+
+    @Override
+    public void updateHistogram(String name, long value) {
+      registry.histogram(name).update(value);
+    }
+    
+    @Override
+    public void updateTimer(String name, long duration, TimeUnit unit) {
+      registry.timer(name).update(duration, unit);
+    }
+    
+  }
+
 }
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RateLimiter.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RateLimiter.java
new file mode 100644
index 0000000..cd2ea5b
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RateLimiter.java
@@ -0,0 +1,633 @@
+// copied from guava-19.0 to gain access to internal reserve() method
+/*
+ * Copyright (C) 2012 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kitesdk.morphline.solr;
+
+import static com.google.common.base.Preconditions.checkArgument;
+import static com.google.common.base.Preconditions.checkNotNull;
+import static com.google.common.base.Preconditions.checkState;
+import static java.lang.Math.max;
+import static java.util.concurrent.TimeUnit.DAYS;
+import static java.util.concurrent.TimeUnit.HOURS;
+import static java.util.concurrent.TimeUnit.MICROSECONDS;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.MINUTES;
+import static java.util.concurrent.TimeUnit.NANOSECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import java.util.Locale;
+import java.util.concurrent.TimeUnit;
+
+import javax.annotation.CheckReturnValue;
+import javax.annotation.concurrent.ThreadSafe;
+
+import com.google.common.annotations.Beta;
+import com.google.common.annotations.GwtIncompatible;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.base.Ticker;
+import com.google.common.util.concurrent.Uninterruptibles;
+
+/**
+ * A rate limiter. Conceptually, a rate limiter distributes permits at a
+ * configurable rate. Each {@link #acquire()} blocks if necessary until a permit is
+ * available, and then takes it. Once acquired, permits need not be released.
+ *
+ * <p>Rate limiters are often used to restrict the rate at which some
+ * physical or logical resource is accessed. This is in contrast to {@link
+ * java.util.concurrent.Semaphore} which restricts the number of concurrent
+ * accesses instead of the rate (note though that concurrency and rate are closely related,
+ * e.g. see <a href="http://en.wikipedia.org/wiki/Little%27s_law">Little's Law</a>).
+ *
+ * <p>A {@code RateLimiter} is defined primarily by the rate at which permits
+ * are issued. Absent additional configuration, permits will be distributed at a
+ * fixed rate, defined in terms of permits per second. Permits will be distributed
+ * smoothly, with the delay between individual permits being adjusted to ensure
+ * that the configured rate is maintained.
+ *
+ * <p>It is possible to configure a {@code RateLimiter} to have a warmup
+ * period during which time the permits issued each second steadily increases until
+ * it hits the stable rate.
+ *
+ * <p>As an example, imagine that we have a list of tasks to execute, but we don't want to
+ * submit more than 2 per second:
+ *<pre>  {@code
+ *  final RateLimiter rateLimiter = RateLimiter.create(2.0); // rate is "2 permits per second"
+ *  void submitTasks(List<Runnable> tasks, Executor executor) {
+ *    for (Runnable task : tasks) {
+ *      rateLimiter.acquire(); // may wait
+ *      executor.execute(task);
+ *    }
+ *  }
+ *}</pre>
+ *
+ * <p>As another example, imagine that we produce a stream of data, and we want to cap it
+ * at 5kb per second. This could be accomplished by requiring a permit per byte, and specifying
+ * a rate of 5000 permits per second:
+ *<pre>  {@code
+ *  final RateLimiter rateLimiter = RateLimiter.create(5000.0); // rate = 5000 permits per second
+ *  void submitPacket(byte[] packet) {
+ *    rateLimiter.acquire(packet.length);
+ *    networkService.send(packet);
+ *  }
+ *}</pre>
+ *
+ * <p>It is important to note that the number of permits requested <i>never</i>
+ * affects the throttling of the request itself (an invocation to {@code acquire(1)}
+ * and an invocation to {@code acquire(1000)} will result in exactly the same throttling, if any),
+ * but it affects the throttling of the <i>next</i> request. I.e., if an expensive task
+ * arrives at an idle RateLimiter, it will be granted immediately, but it is the <i>next</i>
+ * request that will experience extra throttling, thus paying for the cost of the expensive
+ * task.
+ *
+ * <p>Note: {@code RateLimiter} does not provide fairness guarantees.
+ *
+ * @author Dimitris Andreou
+ * @since 13.0
+ */
+// TODO(user): switch to nano precision. A natural unit of cost is "bytes", and a micro precision
+//     would mean a maximum rate of "1MB/s", which might be small in some cases.
+@ThreadSafe
+@Beta
+abstract class RateLimiter {
+  /**
+   * Creates a {@code RateLimiter} with the specified stable throughput, given as
+   * "permits per second" (commonly referred to as <i>QPS</i>, queries per second).
+   *
+   * <p>The returned {@code RateLimiter} ensures that on average no more than {@code
+   * permitsPerSecond} are issued during any given second, with sustained requests
+   * being smoothly spread over each second. When the incoming request rate exceeds
+   * {@code permitsPerSecond} the rate limiter will release one permit every {@code
+   * (1.0 / permitsPerSecond)} seconds. When the rate limiter is unused,
+   * bursts of up to {@code permitsPerSecond} permits will be allowed, with subsequent
+   * requests being smoothly limited at the stable rate of {@code permitsPerSecond}.
+   *
+   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in
+   *        how many permits become available per second
+   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
+   */
+  // TODO(user): "This is equivalent to
+  //                 {@code createWithCapacity(permitsPerSecond, 1, TimeUnit.SECONDS)}".
+  public static RateLimiter create(double permitsPerSecond) {
+    /*
+     * The default RateLimiter configuration can save the unused permits of up to one second.
+     * This is to avoid unnecessary stalls in situations like this: A RateLimiter of 1qps,
+     * and 4 threads, all calling acquire() at these moments:
+     *
+     * T0 at 0 seconds
+     * T1 at 1.05 seconds
+     * T2 at 2 seconds
+     * T3 at 3 seconds
+     *
+     * Due to the slight delay of T1, T2 would have to sleep till 2.05 seconds,
+     * and T3 would also have to sleep till 3.05 seconds.
+     */
+    return create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond);
+  }
+
+  /*
+   * TODO(cpovirk): make SleepingStopwatch the last parameter throughout the class so that the
+   * overloads follow the usual convention: Foo(int), Foo(int, SleepingStopwatch)
+   */
+  @VisibleForTesting
+  static RateLimiter create(SleepingStopwatch stopwatch, double permitsPerSecond) {
+    RateLimiter rateLimiter = new SmoothRateLimiter.SmoothBursty(stopwatch, 1.0 /* maxBurstSeconds */);
+    rateLimiter.setRate(permitsPerSecond);
+    return rateLimiter;
+  }
+
+  /**
+   * Creates a {@code RateLimiter} with the specified stable throughput, given as
+   * "permits per second" (commonly referred to as <i>QPS</i>, queries per second), and a
+   * <i>warmup period</i>, during which the {@code RateLimiter} smoothly ramps up its rate,
+   * until it reaches its maximum rate at the end of the period (as long as there are enough
+   * requests to saturate it). Similarly, if the {@code RateLimiter} is left <i>unused</i> for
+   * a duration of {@code warmupPeriod}, it will gradually return to its "cold" state,
+   * i.e. it will go through the same warming up process as when it was first created.
+   *
+   * <p>The returned {@code RateLimiter} is intended for cases where the resource that actually
+   * fulfills the requests (e.g., a remote server) needs "warmup" time, rather than
+   * being immediately accessed at the stable (maximum) rate.
+   *
+   * <p>The returned {@code RateLimiter} starts in a "cold" state (i.e. the warmup period
+   * will follow), and if it is left unused for long enough, it will return to that state.
+   *
+   * @param permitsPerSecond the rate of the returned {@code RateLimiter}, measured in
+   *        how many permits become available per second
+   * @param warmupPeriod the duration of the period where the {@code RateLimiter} ramps up its
+   *        rate, before reaching its stable (maximum) rate
+   * @param unit the time unit of the warmupPeriod argument
+   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero or
+   *     {@code warmupPeriod} is negative
+   */
+  public static RateLimiter create(double permitsPerSecond, long warmupPeriod, TimeUnit unit) {
+    checkArgument(warmupPeriod >= 0, "warmupPeriod must not be negative: %s", warmupPeriod);
+    return create(SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit,
+                  3.0);
+  }
+
+  @VisibleForTesting
+  static RateLimiter create(
+      SleepingStopwatch stopwatch, double permitsPerSecond, long warmupPeriod, TimeUnit unit,
+      double coldFactor) {
+    RateLimiter rateLimiter = new SmoothRateLimiter.SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);
+    rateLimiter.setRate(permitsPerSecond);
+    return rateLimiter;
+  }
+
+  /**
+   * The underlying timer; used both to measure elapsed time and sleep as necessary. A separate
+   * object to facilitate testing.
+   */
+  private final SleepingStopwatch stopwatch;
+
+  // Can't be initialized in the constructor because mocks don't call the constructor.
+  private volatile Object mutexDoNotUseDirectly;
+
+  private Object mutex() {
+    Object mutex = mutexDoNotUseDirectly;
+    if (mutex == null) {
+      synchronized (this) {
+        mutex = mutexDoNotUseDirectly;
+        if (mutex == null) {
+          mutexDoNotUseDirectly = mutex = new Object();
+        }
+      }
+    }
+    return mutex;
+  }
+
+  RateLimiter(SleepingStopwatch stopwatch) {
+    this.stopwatch = checkNotNull(stopwatch);
+  }
+
+  /**
+   * Updates the stable rate of this {@code RateLimiter}, that is, the
+   * {@code permitsPerSecond} argument provided in the factory method that
+   * constructed the {@code RateLimiter}. Currently throttled threads will <b>not</b>
+   * be awakened as a result of this invocation, thus they do not observe the new rate;
+   * only subsequent requests will.
+   *
+   * <p>Note though that, since each request repays (by waiting, if necessary) the cost
+   * of the <i>previous</i> request, this means that the very next request
+   * after an invocation to {@code setRate} will not be affected by the new rate;
+   * it will pay the cost of the previous request, which is in terms of the previous rate.
+   *
+   * <p>The behavior of the {@code RateLimiter} is not modified in any other way,
+   * e.g. if the {@code RateLimiter} was configured with a warmup period of 20 seconds,
+   * it still has a warmup period of 20 seconds after this method invocation.
+   *
+   * @param permitsPerSecond the new stable rate of this {@code RateLimiter}
+   * @throws IllegalArgumentException if {@code permitsPerSecond} is negative or zero
+   */
+  public final void setRate(double permitsPerSecond) {
+    checkArgument(
+        permitsPerSecond > 0.0 && !Double.isNaN(permitsPerSecond), "rate must be positive");
+    synchronized (mutex()) {
+      doSetRate(permitsPerSecond, stopwatch.readMicros());
+    }
+  }
+
+  abstract void doSetRate(double permitsPerSecond, long nowMicros);
+
+  /**
+   * Returns the stable rate (as {@code permits per seconds}) with which this
+   * {@code RateLimiter} is configured with. The initial value of this is the same as
+   * the {@code permitsPerSecond} argument passed in the factory method that produced
+   * this {@code RateLimiter}, and it is only updated after invocations
+   * to {@linkplain #setRate}.
+   */
+  public final double getRate() {
+    synchronized (mutex()) {
+      return doGetRate();
+    }
+  }
+
+  abstract double doGetRate();
+
+  /**
+   * Acquires a single permit from this {@code RateLimiter}, blocking until the
+   * request can be granted. Tells the amount of time slept, if any.
+   *
+   * <p>This method is equivalent to {@code acquire(1)}.
+   *
+   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
+   * @since 16.0 (present in 13.0 with {@code void} return type})
+   */
+  public double acquire() {
+    return acquire(1);
+  }
+
+  /**
+   * Acquires the given number of permits from this {@code RateLimiter}, blocking until the
+   * request can be granted. Tells the amount of time slept, if any.
+   *
+   * @param permits the number of permits to acquire
+   * @return time spent sleeping to enforce rate, in seconds; 0.0 if not rate-limited
+   * @throws IllegalArgumentException if the requested number of permits is negative or zero
+   * @since 16.0 (present in 13.0 with {@code void} return type})
+   */
+  public double acquire(int permits) {
+    long microsToWait = reserve(permits);
+    stopwatch.sleepMicrosUninterruptibly(microsToWait);
+    return 1.0 * microsToWait / SECONDS.toMicros(1L);
+  }
+
+  /**
+   * Reserves the given number of permits from this {@code RateLimiter} for future use, returning
+   * the number of microseconds until the reservation can be consumed.
+   *
+   * @return time in microseconds to wait until the resource can be acquired, never negative
+   */
+  final long reserve(int permits) {
+    checkPermits(permits);
+    synchronized (mutex()) {
+      return reserveAndGetWaitLength(permits, stopwatch.readMicros());
+    }
+  }
+
+  /**
+   * Acquires a permit from this {@code RateLimiter} if it can be obtained
+   * without exceeding the specified {@code timeout}, or returns {@code false}
+   * immediately (without waiting) if the permit would not have been granted
+   * before the timeout expired.
+   *
+   * <p>This method is equivalent to {@code tryAcquire(1, timeout, unit)}.
+   *
+   * @param timeout the maximum time to wait for the permit. Negative values are treated as zero.
+   * @param unit the time unit of the timeout argument
+   * @return {@code true} if the permit was acquired, {@code false} otherwise
+   * @throws IllegalArgumentException if the requested number of permits is negative or zero
+   */
+  public boolean tryAcquire(long timeout, TimeUnit unit) {
+    return tryAcquire(1, timeout, unit);
+  }
+
+  /**
+   * Acquires permits from this {@link RateLimiter} if it can be acquired immediately without delay.
+   *
+   * <p>
+   * This method is equivalent to {@code tryAcquire(permits, 0, anyUnit)}.
+   *
+   * @param permits the number of permits to acquire
+   * @return {@code true} if the permits were acquired, {@code false} otherwise
+   * @throws IllegalArgumentException if the requested number of permits is negative or zero
+   * @since 14.0
+   */
+  public boolean tryAcquire(int permits) {
+    return tryAcquire(permits, 0, MICROSECONDS);
+  }
+
+  /**
+   * Acquires a permit from this {@link RateLimiter} if it can be acquired immediately without
+   * delay.
+   *
+   * <p>
+   * This method is equivalent to {@code tryAcquire(1)}.
+   *
+   * @return {@code true} if the permit was acquired, {@code false} otherwise
+   * @since 14.0
+   */
+  public boolean tryAcquire() {
+    return tryAcquire(1, 0, MICROSECONDS);
+  }
+
+  /**
+   * Acquires the given number of permits from this {@code RateLimiter} if it can be obtained
+   * without exceeding the specified {@code timeout}, or returns {@code false}
+   * immediately (without waiting) if the permits would not have been granted
+   * before the timeout expired.
+   *
+   * @param permits the number of permits to acquire
+   * @param timeout the maximum time to wait for the permits. Negative values are treated as zero.
+   * @param unit the time unit of the timeout argument
+   * @return {@code true} if the permits were acquired, {@code false} otherwise
+   * @throws IllegalArgumentException if the requested number of permits is negative or zero
+   */
+  public boolean tryAcquire(int permits, long timeout, TimeUnit unit) {
+    long timeoutMicros = max(unit.toMicros(timeout), 0);
+    checkPermits(permits);
+    long microsToWait;
+    synchronized (mutex()) {
+      long nowMicros = stopwatch.readMicros();
+      if (!canAcquire(nowMicros, timeoutMicros)) {
+        return false;
+      } else {
+        microsToWait = reserveAndGetWaitLength(permits, nowMicros);
+      }
+    }
+    stopwatch.sleepMicrosUninterruptibly(microsToWait);
+    return true;
+  }
+
+  private boolean canAcquire(long nowMicros, long timeoutMicros) {
+    return queryEarliestAvailable(nowMicros) - timeoutMicros <= nowMicros;
+  }
+
+  /**
+   * Reserves next ticket and returns the wait time that the caller must wait for.
+   *
+   * @return the required wait time, never negative
+   */
+  final long reserveAndGetWaitLength(int permits, long nowMicros) {
+    long momentAvailable = reserveEarliestAvailable(permits, nowMicros);
+    return max(momentAvailable - nowMicros, 0);
+  }
+
+  /**
+   * Returns the earliest time that permits are available (with one caveat).
+   *
+   * @return the time that permits are available, or, if permits are available immediately, an
+   *     arbitrary past or present time
+   */
+  abstract long queryEarliestAvailable(long nowMicros);
+
+    /**
+   * Reserves the requested number of permits and returns the time that those permits can be used
+   * (with one caveat).
+     *
+   * @return the time that the permits may be used, or, if the permits may be used immediately, an
+   *     arbitrary past or present time
+     */
+  abstract long reserveEarliestAvailable(int permits, long nowMicros);
+
+  @Override
+  public String toString() {
+    return String.format(Locale.ROOT, "RateLimiter[stableRate=%3.1fqps]", getRate());
+  }
+
+  @VisibleForTesting
+  abstract static class SleepingStopwatch {
+    /*
+     * We always hold the mutex when calling this. TODO(cpovirk): Is that important? Perhaps we need
+     * to guarantee that each call to reserveEarliestAvailable, etc. sees a value >= the previous?
+     * Also, is it OK that we don't hold the mutex when sleeping?
+     */
+    abstract long readMicros();
+
+    abstract void sleepMicrosUninterruptibly(long micros);
+
+    static final SleepingStopwatch createFromSystemTimer() {
+      return new SleepingStopwatch() {
+        final Stopwatch stopwatch = Stopwatch.createStarted();
+
+        @Override
+        long readMicros() {
+          return stopwatch.elapsed(MICROSECONDS);
+        }
+
+        @Override
+        void sleepMicrosUninterruptibly(long micros) {
+          if (micros > 0) {
+            Uninterruptibles.sleepUninterruptibly(micros, MICROSECONDS);
+          }
+        }
+      };
+    }
+  }
+
+  private static int checkPermits(int permits) {
+    checkArgument(permits > 0, "Requested permits (%s) must be positive", permits);
+    return permits;
+  }
+  
+  private static final class Stopwatch {
+    private final Ticker ticker;
+    private boolean isRunning;
+    private long elapsedNanos;
+    private long startTick;
+
+    /**
+     * Creates (but does not start) a new stopwatch using {@link System#nanoTime}
+     * as its time source.
+     *
+     * @since 15.0
+     */
+    @CheckReturnValue
+    public static Stopwatch createUnstarted() {
+      return new Stopwatch();
+    }
+
+    /**
+     * Creates (but does not start) a new stopwatch, using the specified time
+     * source.
+     *
+     * @since 15.0
+     */
+    @CheckReturnValue
+    public static Stopwatch createUnstarted(Ticker ticker) {
+      return new Stopwatch(ticker);
+    }
+
+    /**
+     * Creates (and starts) a new stopwatch using {@link System#nanoTime}
+     * as its time source.
+     *
+     * @since 15.0
+     */
+    @CheckReturnValue
+    public static Stopwatch createStarted() {
+      return new Stopwatch().start();
+    }
+
+    /**
+     * Creates (and starts) a new stopwatch, using the specified time
+     * source.
+     *
+     * @since 15.0
+     */
+    @CheckReturnValue
+    public static Stopwatch createStarted(Ticker ticker) {
+      return new Stopwatch(ticker).start();
+    }
+
+    Stopwatch() {
+      this.ticker = Ticker.systemTicker();
+    }
+
+    Stopwatch(Ticker ticker) {
+      this.ticker = checkNotNull(ticker, "ticker");
+    }
+
+    /**
+     * Returns {@code true} if {@link #start()} has been called on this stopwatch,
+     * and {@link #stop()} has not been called since the last call to {@code
+     * start()}.
+     */
+    @CheckReturnValue
+    public boolean isRunning() {
+      return isRunning;
+    }
+
+    /**
+     * Starts the stopwatch.
+     *
+     * @return this {@code Stopwatch} instance
+     * @throws IllegalStateException if the stopwatch is already running.
+     */
+    public Stopwatch start() {
+      checkState(!isRunning, "This stopwatch is already running.");
+      isRunning = true;
+      startTick = ticker.read();
+      return this;
+    }
+
+    /**
+     * Stops the stopwatch. Future reads will return the fixed duration that had
+     * elapsed up to this point.
+     *
+     * @return this {@code Stopwatch} instance
+     * @throws IllegalStateException if the stopwatch is already stopped.
+     */
+    public Stopwatch stop() {
+      long tick = ticker.read();
+      checkState(isRunning, "This stopwatch is already stopped.");
+      isRunning = false;
+      elapsedNanos += tick - startTick;
+      return this;
+    }
+
+    /**
+     * Sets the elapsed time for this stopwatch to zero,
+     * and places it in a stopped state.
+     *
+     * @return this {@code Stopwatch} instance
+     */
+    public Stopwatch reset() {
+      elapsedNanos = 0;
+      isRunning = false;
+      return this;
+    }
+
+    private long elapsedNanos() {
+      return isRunning ? ticker.read() - startTick + elapsedNanos : elapsedNanos;
+    }
+
+    /**
+     * Returns the current elapsed time shown on this stopwatch, expressed
+     * in the desired time unit, with any fraction rounded down.
+     *
+     * <p>Note that the overhead of measurement can be more than a microsecond, so
+     * it is generally not useful to specify {@link TimeUnit#NANOSECONDS}
+     * precision here.
+     *
+     * @since 14.0 (since 10.0 as {@code elapsedTime()})
+     */
+    @CheckReturnValue
+    public long elapsed(TimeUnit desiredUnit) {
+      return desiredUnit.convert(elapsedNanos(), NANOSECONDS);
+    }
+
+    /**
+     * Returns a string representation of the current elapsed time.
+     */
+    @GwtIncompatible("String.format()")
+    @Override
+    public String toString() {
+      long nanos = elapsedNanos();
+
+      TimeUnit unit = chooseUnit(nanos);
+      double value = (double) nanos / NANOSECONDS.convert(1, unit);
+
+      // Too bad this functionality is not exposed as a regular method call
+      return String.format(Locale.ROOT, "%.4g %s", value, abbreviate(unit));
+    }
+
+    private static TimeUnit chooseUnit(long nanos) {
+      if (DAYS.convert(nanos, NANOSECONDS) > 0) {
+        return DAYS;
+      }
+      if (HOURS.convert(nanos, NANOSECONDS) > 0) {
+        return HOURS;
+      }
+      if (MINUTES.convert(nanos, NANOSECONDS) > 0) {
+        return MINUTES;
+      }
+      if (SECONDS.convert(nanos, NANOSECONDS) > 0) {
+        return SECONDS;
+      }
+      if (MILLISECONDS.convert(nanos, NANOSECONDS) > 0) {
+        return MILLISECONDS;
+      }
+      if (MICROSECONDS.convert(nanos, NANOSECONDS) > 0) {
+        return MICROSECONDS;
+      }
+      return NANOSECONDS;
+    }
+
+    private static String abbreviate(TimeUnit unit) {
+      switch (unit) {
+        case NANOSECONDS:
+          return "ns";
+        case MICROSECONDS:
+          return "\u03bcs"; // s
+        case MILLISECONDS:
+          return "ms";
+        case SECONDS:
+          return "s";
+        case MINUTES:
+          return "min";
+        case HOURS:
+          return "h";
+        case DAYS:
+          return "d";
+        default:
+          throw new AssertionError();
+      }
+    }
+  }
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RetryPolicyFactoryParser.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RetryPolicyFactoryParser.java
new file mode 100644
index 0000000..fec196e
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/RetryPolicyFactoryParser.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kitesdk.morphline.solr;
+
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.solr.client.solrj.retry.DefaultRetryPolicyFactory;
+import org.apache.solr.client.solrj.retry.FlexibleBoundedExponentialBackoffRetry;
+import org.apache.solr.client.solrj.retry.RetryPolicyFactory;
+import org.kitesdk.morphline.base.Configs;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.typesafe.config.Config;
+
+final class RetryPolicyFactoryParser {
+ 
+  public static final String BOUNDED_EXPONENTIAL_BACKOFF_RETRY_NAME = "BoundedExponentialBackoffRetry";
+  
+  private static final Logger LOG = LoggerFactory.getLogger(RetryPolicyFactoryParser.class);
+      
+  public RetryPolicyFactory parse(Config retryPolicyConfig) {    
+    final Config boundedExponentialBackoffRetryConfig = new Configs().getConfig(retryPolicyConfig, 
+        BOUNDED_EXPONENTIAL_BACKOFF_RETRY_NAME);
+    final long baseSleepTime = new Configs()
+        .getNanoseconds(boundedExponentialBackoffRetryConfig, "baseSleepTime", TimeUnit.MILLISECONDS.toNanos(1000));
+    final long maxSleepTime = new Configs()
+        .getNanoseconds(boundedExponentialBackoffRetryConfig, "maxSleepTime", TimeUnit.SECONDS.toNanos(10));
+    final int maxRetries = new Configs()
+        .getInt(boundedExponentialBackoffRetryConfig, "maxRetries", 100);
+    final long maxElapsedTime = new Configs()
+        .getNanoseconds(boundedExponentialBackoffRetryConfig, "maxElapsedTime", TimeUnit.SECONDS.toNanos(3 * 60));
+    LOG.debug("Parsed retry policy BoundedExponentialBackoffRetry with "
+        + "baseSleepTime:{}, maxSleepTime:{}, maxRetries:{}, maxElapsedTime:{}",
+        Arrays.asList(baseSleepTime, maxSleepTime, maxRetries, maxElapsedTime));
+    if (maxRetries <= 0 || maxElapsedTime <= 0) {
+      return null;
+    }
+    return new DefaultRetryPolicyFactory(
+        new FlexibleBoundedExponentialBackoffRetry(baseSleepTime, maxSleepTime, maxRetries, maxElapsedTime));
+  }
+
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SmoothRateLimiter.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SmoothRateLimiter.java
new file mode 100644
index 0000000..757339a
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SmoothRateLimiter.java
@@ -0,0 +1,397 @@
+// copied from guava-19.0
+/*
+ * Copyright (C) 2012 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kitesdk.morphline.solr;
+
+import static java.lang.Math.min;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
+import java.util.concurrent.TimeUnit;
+
+import com.google.common.math.LongMath;
+
+abstract class SmoothRateLimiter extends RateLimiter {
+  /*
+   * How is the RateLimiter designed, and why?
+   *
+   * The primary feature of a RateLimiter is its "stable rate", the maximum rate that
+   * is should allow at normal conditions. This is enforced by "throttling" incoming
+   * requests as needed, i.e. compute, for an incoming request, the appropriate throttle time,
+   * and make the calling thread wait as much.
+   *
+   * The simplest way to maintain a rate of QPS is to keep the timestamp of the last
+   * granted request, and ensure that (1/QPS) seconds have elapsed since then. For example,
+   * for a rate of QPS=5 (5 tokens per second), if we ensure that a request isn't granted
+   * earlier than 200ms after the last one, then we achieve the intended rate.
+   * If a request comes and the last request was granted only 100ms ago, then we wait for
+   * another 100ms. At this rate, serving 15 fresh permits (i.e. for an acquire(15) request)
+   * naturally takes 3 seconds.
+   *
+   * It is important to realize that such a RateLimiter has a very superficial memory
+   * of the past: it only remembers the last request. What if the RateLimiter was unused for
+   * a long period of time, then a request arrived and was immediately granted?
+   * This RateLimiter would immediately forget about that past underutilization. This may
+   * result in either underutilization or overflow, depending on the real world consequences
+   * of not using the expected rate.
+   *
+   * Past underutilization could mean that excess resources are available. Then, the RateLimiter
+   * should speed up for a while, to take advantage of these resources. This is important
+   * when the rate is applied to networking (limiting bandwidth), where past underutilization
+   * typically translates to "almost empty buffers", which can be filled immediately.
+   *
+   * On the other hand, past underutilization could mean that "the server responsible for
+   * handling the request has become less ready for future requests", i.e. its caches become
+   * stale, and requests become more likely to trigger expensive operations (a more extreme
+   * case of this example is when a server has just booted, and it is mostly busy with getting
+   * itself up to speed).
+   *
+   * To deal with such scenarios, we add an extra dimension, that of "past underutilization",
+   * modeled by "storedPermits" variable. This variable is zero when there is no
+   * underutilization, and it can grow up to maxStoredPermits, for sufficiently large
+   * underutilization. So, the requested permits, by an invocation acquire(permits),
+   * are served from:
+   * - stored permits (if available)
+   * - fresh permits (for any remaining permits)
+   *
+   * How this works is best explained with an example:
+   *
+   * For a RateLimiter that produces 1 token per second, every second
+   * that goes by with the RateLimiter being unused, we increase storedPermits by 1.
+   * Say we leave the RateLimiter unused for 10 seconds (i.e., we expected a request at time
+   * X, but we are at time X + 10 seconds before a request actually arrives; this is
+   * also related to the point made in the last paragraph), thus storedPermits
+   * becomes 10.0 (assuming maxStoredPermits >= 10.0). At that point, a request of acquire(3)
+   * arrives. We serve this request out of storedPermits, and reduce that to 7.0 (how this is
+   * translated to throttling time is discussed later). Immediately after, assume that an
+   * acquire(10) request arriving. We serve the request partly from storedPermits,
+   * using all the remaining 7.0 permits, and the remaining 3.0, we serve them by fresh permits
+   * produced by the rate limiter.
+   *
+   * We already know how much time it takes to serve 3 fresh permits: if the rate is
+   * "1 token per second", then this will take 3 seconds. But what does it mean to serve 7
+   * stored permits? As explained above, there is no unique answer. If we are primarily
+   * interested to deal with underutilization, then we want stored permits to be given out
+   * /faster/ than fresh ones, because underutilization = free resources for the taking.
+   * If we are primarily interested to deal with overflow, then stored permits could
+   * be given out /slower/ than fresh ones. Thus, we require a (different in each case)
+   * function that translates storedPermits to throtting time.
+   *
+   * This role is played by storedPermitsToWaitTime(double storedPermits, double permitsToTake).
+   * The underlying model is a continuous function mapping storedPermits
+   * (from 0.0 to maxStoredPermits) onto the 1/rate (i.e. intervals) that is effective at the given
+   * storedPermits. "storedPermits" essentially measure unused time; we spend unused time
+   * buying/storing permits. Rate is "permits / time", thus "1 / rate = time / permits".
+   * Thus, "1/rate" (time / permits) times "permits" gives time, i.e., integrals on this
+   * function (which is what storedPermitsToWaitTime() computes) correspond to minimum intervals
+   * between subsequent requests, for the specified number of requested permits.
+   *
+   * Here is an example of storedPermitsToWaitTime:
+   * If storedPermits == 10.0, and we want 3 permits, we take them from storedPermits,
+   * reducing them to 7.0, and compute the throttling for these as a call to
+   * storedPermitsToWaitTime(storedPermits = 10.0, permitsToTake = 3.0), which will
+   * evaluate the integral of the function from 7.0 to 10.0.
+   *
+   * Using integrals guarantees that the effect of a single acquire(3) is equivalent
+   * to { acquire(1); acquire(1); acquire(1); }, or { acquire(2); acquire(1); }, etc,
+   * since the integral of the function in [7.0, 10.0] is equivalent to the sum of the
+   * integrals of [7.0, 8.0], [8.0, 9.0], [9.0, 10.0] (and so on), no matter
+   * what the function is. This guarantees that we handle correctly requests of varying weight
+   * (permits), /no matter/ what the actual function is - so we can tweak the latter freely.
+   * (The only requirement, obviously, is that we can compute its integrals).
+   *
+   * Note well that if, for this function, we chose a horizontal line, at height of exactly
+   * (1/QPS), then the effect of the function is non-existent: we serve storedPermits at
+   * exactly the same cost as fresh ones (1/QPS is the cost for each). We use this trick later.
+   *
+   * If we pick a function that goes /below/ that horizontal line, it means that we reduce
+   * the area of the function, thus time. Thus, the RateLimiter becomes /faster/ after a
+   * period of underutilization. If, on the other hand, we pick a function that
+   * goes /above/ that horizontal line, then it means that the area (time) is increased,
+   * thus storedPermits are more costly than fresh permits, thus the RateLimiter becomes
+   * /slower/ after a period of underutilization.
+   *
+   * Last, but not least: consider a RateLimiter with rate of 1 permit per second, currently
+   * completely unused, and an expensive acquire(100) request comes. It would be nonsensical
+   * to just wait for 100 seconds, and /then/ start the actual task. Why wait without doing
+   * anything? A much better approach is to /allow/ the request right away (as if it was an
+   * acquire(1) request instead), and postpone /subsequent/ requests as needed. In this version,
+   * we allow starting the task immediately, and postpone by 100 seconds future requests,
+   * thus we allow for work to get done in the meantime instead of waiting idly.
+   *
+   * This has important consequences: it means that the RateLimiter doesn't remember the time
+   * of the _last_ request, but it remembers the (expected) time of the _next_ request. This
+   * also enables us to tell immediately (see tryAcquire(timeout)) whether a particular
+   * timeout is enough to get us to the point of the next scheduling time, since we always
+   * maintain that. And what we mean by "an unused RateLimiter" is also defined by that
+   * notion: when we observe that the "expected arrival time of the next request" is actually
+   * in the past, then the difference (now - past) is the amount of time that the RateLimiter
+   * was formally unused, and it is that amount of time which we translate to storedPermits.
+   * (We increase storedPermits with the amount of permits that would have been produced
+   * in that idle time). So, if rate == 1 permit per second, and arrivals come exactly
+   * one second after the previous, then storedPermits is _never_ increased -- we would only
+   * increase it for arrivals _later_ than the expected one second.
+   */
+
+  /**
+   * This implements the following function where coldInterval = coldFactor * stableInterval.
+   *
+   *          ^ throttling
+   *          |
+   *    cold  +                  /
+   * interval |                 /.
+   *          |                / .
+   *          |               /  .   <-- "warmup period" is the area of the trapezoid between
+   *          |              /   .       thresholdPermits and maxPermits
+   *          |             /    .
+   *          |            /     .
+   *          |           /      .
+   *   stable +----------/  WARM .
+   * interval |          .   UP  .
+   *          |          . PERIOD.
+   *          |          .       .
+   *        0 +----------+-------+--------------> storedPermits
+   *          0 thresholdPermits maxPermits
+   * Before going into the details of this particular function, let's keep in mind the basics:
+   * 1) The state of the RateLimiter (storedPermits) is a vertical line in this figure.
+   * 2) When the RateLimiter is not used, this goes right (up to maxPermits)
+   * 3) When the RateLimiter is used, this goes left (down to zero), since if we have storedPermits,
+   *    we serve from those first
+   * 4) When _unused_, we go right at a constant rate! The rate at which we move to
+   *    the right is chosen as maxPermits / warmupPeriod.  This ensures that the time it takes to
+   *    go from 0 to maxPermits is equal to warmupPeriod.
+   * 5) When _used_, the time it takes, as explained in the introductory class note, is
+   *    equal to the integral of our function, between X permits and X-K permits, assuming
+   *    we want to spend K saved permits.
+   *
+   *    In summary, the time it takes to move to the left (spend K permits), is equal to the
+   *    area of the function of width == K.
+   *
+   *    Assuming we have saturated demand, the time to go from maxPermits to thresholdPermits is
+   *    equal to warmupPeriod.  And the time to go from thresholdPermits to 0 is
+   *    warmupPeriod/2.  (The reason that this is warmupPeriod/2 is to maintain the behavior of
+   *    the original implementation where coldFactor was hard coded as 3.)
+   *
+   *  It remains to calculate thresholdsPermits and maxPermits.
+   *
+   *  - The time to go from thresholdPermits to 0 is equal to the integral of the function between
+   *    0 and thresholdPermits.  This is thresholdPermits * stableIntervals.  By (5) it is also
+   *    equal to warmupPeriod/2.  Therefore
+   *
+   *        thresholdPermits = 0.5 * warmupPeriod / stableInterval.
+   *
+   *  - The time to go from maxPermits to thresholdPermits is equal to the integral of the function
+   *    between thresholdPermits and maxPermits.  This is the area of the pictured trapezoid, and it
+   *    is equal to 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits).  It is
+   *    also equal to warmupPeriod, so
+   *
+   *        maxPermits = thresholdPermits + 2 * warmupPeriod / (stableInterval + coldInterval).
+   */
+  static final class SmoothWarmingUp extends SmoothRateLimiter {
+    private final long warmupPeriodMicros;
+    /**
+     * The slope of the line from the stable interval (when permits == 0), to the cold interval
+     * (when permits == maxPermits)
+     */
+    private double slope;
+    private double thresholdPermits;
+    private double coldFactor;
+
+    SmoothWarmingUp(
+        SleepingStopwatch stopwatch, long warmupPeriod, TimeUnit timeUnit, double coldFactor) {
+      super(stopwatch);
+      this.warmupPeriodMicros = timeUnit.toMicros(warmupPeriod);
+      this.coldFactor = coldFactor;
+    }
+
+    @Override
+    void doSetRate(double permitsPerSecond, double stableIntervalMicros) {
+      double oldMaxPermits = maxPermits;
+      double coldIntervalMicros = stableIntervalMicros * coldFactor;
+      thresholdPermits = 0.5 * warmupPeriodMicros / stableIntervalMicros;
+      maxPermits = thresholdPermits
+          + 2.0 * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);
+      slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);
+      if (oldMaxPermits == Double.POSITIVE_INFINITY) {
+        // if we don't special-case this, we would get storedPermits == NaN, below
+        storedPermits = 0.0;
+      } else {
+        storedPermits = (oldMaxPermits == 0.0)
+            ? maxPermits // initial state is cold
+            : storedPermits * maxPermits / oldMaxPermits;
+      }
+    }
+
+    @Override
+    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
+      double availablePermitsAboveThreshold = storedPermits - thresholdPermits;
+      long micros = 0;
+      // measuring the integral on the right part of the function (the climbing line)
+      if (availablePermitsAboveThreshold > 0.0) {
+        double permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);
+        micros = (long) (permitsAboveThresholdToTake
+            * (permitsToTime(availablePermitsAboveThreshold)
+            + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake)) / 2.0);
+        permitsToTake -= permitsAboveThresholdToTake;
+      }
+      // measuring the integral on the left part of the function (the horizontal line)
+      micros += (stableIntervalMicros * permitsToTake);
+      return micros;
+    }
+
+    private double permitsToTime(double permits) {
+      return stableIntervalMicros + permits * slope;
+    }
+
+    @Override
+    double coolDownIntervalMicros() {
+      return warmupPeriodMicros / maxPermits;
+    }
+  }
+
+  /**
+   * This implements a "bursty" RateLimiter, where storedPermits are translated to
+   * zero throttling. The maximum number of permits that can be saved (when the RateLimiter is
+   * unused) is defined in terms of time, in this sense: if a RateLimiter is 2qps, and this
+   * time is specified as 10 seconds, we can save up to 2 * 10 = 20 permits.
+   */
+  static final class SmoothBursty extends SmoothRateLimiter {
+    /** The work (permits) of how many seconds can be saved up if this RateLimiter is unused? */
+    final double maxBurstSeconds;
+
+    SmoothBursty(SleepingStopwatch stopwatch, double maxBurstSeconds) {
+      super(stopwatch);
+      this.maxBurstSeconds = maxBurstSeconds;
+    }
+
+    @Override
+    void doSetRate(double permitsPerSecond, double stableIntervalMicros) {
+      double oldMaxPermits = this.maxPermits;
+      maxPermits = maxBurstSeconds * permitsPerSecond;
+      if (oldMaxPermits == Double.POSITIVE_INFINITY) {
+        // if we don't special-case this, we would get storedPermits == NaN, below
+        storedPermits = maxPermits;
+      } else {
+        storedPermits = (oldMaxPermits == 0.0)
+            ? 0.0 // initial state
+            : storedPermits * maxPermits / oldMaxPermits;
+      }
+    }
+
+    @Override
+    long storedPermitsToWaitTime(double storedPermits, double permitsToTake) {
+      return 0L;
+    }
+
+    @Override
+    double coolDownIntervalMicros() {
+      return stableIntervalMicros;
+    }
+  }
+
+  /**
+   * The currently stored permits.
+   */
+  double storedPermits;
+
+  /**
+   * The maximum number of stored permits.
+   */
+  double maxPermits;
+
+  /**
+   * The interval between two unit requests, at our stable rate. E.g., a stable rate of 5 permits
+   * per second has a stable interval of 200ms.
+   */
+  double stableIntervalMicros;
+
+  /**
+   * The time when the next request (no matter its size) will be granted. After granting a
+   * request, this is pushed further in the future. Large requests push this further than small
+   * requests.
+   */
+  private long nextFreeTicketMicros = 0L; // could be either in the past or future
+
+  private SmoothRateLimiter(SleepingStopwatch stopwatch) {
+    super(stopwatch);
+  }
+
+  @Override
+  final void doSetRate(double permitsPerSecond, long nowMicros) {
+    resync(nowMicros);
+    double stableIntervalMicros = SECONDS.toMicros(1L) / permitsPerSecond;
+    this.stableIntervalMicros = stableIntervalMicros;
+    doSetRate(permitsPerSecond, stableIntervalMicros);
+  }
+
+  abstract void doSetRate(double permitsPerSecond, double stableIntervalMicros);
+
+  @Override
+  final double doGetRate() {
+    return SECONDS.toMicros(1L) / stableIntervalMicros;
+  }
+
+  @Override
+  final long queryEarliestAvailable(long nowMicros) {
+    return nextFreeTicketMicros;
+  }
+
+  @Override
+  final long reserveEarliestAvailable(int requiredPermits, long nowMicros) {
+    resync(nowMicros);
+    long returnValue = nextFreeTicketMicros;
+    double storedPermitsToSpend = min(requiredPermits, this.storedPermits);
+    double freshPermits = requiredPermits - storedPermitsToSpend;
+    long waitMicros = storedPermitsToWaitTime(this.storedPermits, storedPermitsToSpend)
+        + (long) (freshPermits * stableIntervalMicros);
+
+    try {
+      this.nextFreeTicketMicros = LongMath.checkedAdd(nextFreeTicketMicros, waitMicros);
+    } catch (ArithmeticException e) {
+      this.nextFreeTicketMicros = Long.MAX_VALUE;
+    }
+    this.storedPermits -= storedPermitsToSpend;
+    return returnValue;
+  }
+
+  /**
+   * Translates a specified portion of our currently stored permits which we want to
+   * spend/acquire, into a throttling time. Conceptually, this evaluates the integral
+   * of the underlying function we use, for the range of
+   * [(storedPermits - permitsToTake), storedPermits].
+   *
+   * <p>This always holds: {@code 0 <= permitsToTake <= storedPermits}
+   */
+  abstract long storedPermitsToWaitTime(double storedPermits, double permitsToTake);
+
+  /**
+   * Returns the number of microseconds during cool down that we have to wait to get a new permit.
+   */
+  abstract double coolDownIntervalMicros();
+
+  /**
+   * Updates {@code storedPermits} and {@code nextFreeTicketMicros} based on the current time.
+   */
+  void resync(long nowMicros) {
+    // if nextFreeTicket is in the past, resync to now
+    if (nowMicros > nextFreeTicketMicros) {
+      storedPermits = min(maxPermits,
+          storedPermits
+            + (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros());
+      nextFreeTicketMicros = nowMicros;
+    }
+  }
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrLocator.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrLocator.java
index 5af3342..a6d75cf 100644
--- a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrLocator.java
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrLocator.java
@@ -23,6 +23,9 @@ import javax.xml.parsers.ParserConfigurationException;
 import org.apache.solr.client.solrj.SolrServer;
 import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;
 import org.apache.solr.client.solrj.impl.CloudSolrServer;
+import org.apache.solr.client.solrj.retry.MetricsFacade;
+import org.apache.solr.client.solrj.retry.RetryPolicyFactory;
+import org.apache.solr.client.solrj.retry.RetryingSolrServer;
 import org.apache.solr.common.cloud.SolrZkClient;
 import org.apache.solr.core.CoreContainer;
 import org.apache.solr.core.SolrConfig;
@@ -117,6 +120,10 @@ public class SolrLocator {
   }
 
   public DocumentLoader getLoader() {
+    return getLoader(null, null);
+  }
+  
+  DocumentLoader getLoader(RetryPolicyFactory retryPolicyFactory, MetricsFacade retryMetricsFacade) {
     if (context instanceof SolrMorphlineContext) {
       DocumentLoader loader = ((SolrMorphlineContext)context).getDocumentLoader();
       if (loader != null) {
@@ -137,6 +144,10 @@ public class SolrLocator {
         throw new RuntimeException(e); // rethrow root cause
       }      
     }
+
+    if (retryPolicyFactory != null) {
+      solrServer = new RetryingSolrServer(solrServer, retryPolicyFactory, retryMetricsFacade);
+    }
     
     return new SolrServerDocumentLoader(solrServer, batchSize);
   }
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrServerDocumentLoader.java b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrServerDocumentLoader.java
index 95a04cf..50cb8f1 100644
--- a/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrServerDocumentLoader.java
+++ b/kite-morphlines/kite-morphlines-solr-core/src/main/java/org/kitesdk/morphline/solr/SolrServerDocumentLoader.java
@@ -26,6 +26,7 @@ import org.apache.solr.client.solrj.impl.ConcurrentUpdateSolrServer;
 import org.apache.solr.client.solrj.request.UpdateRequest;
 import org.apache.solr.client.solrj.response.SolrPingResponse;
 import org.apache.solr.client.solrj.response.UpdateResponse;
+import org.apache.solr.client.solrj.retry.RetryingSolrServer;
 import org.apache.solr.common.SolrInputDocument;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -61,8 +62,9 @@ public class SolrServerDocumentLoader implements DocumentLoader {
     LOGGER.trace("beginTransaction");
     batch.clear();
     numSentItems = 0;
-    if (server instanceof SafeConcurrentUpdateSolrServer) {
-      ((SafeConcurrentUpdateSolrServer) server).clearException();
+    SolrServer s = getNonRetryingSolrServer();
+    if (s instanceof SafeConcurrentUpdateSolrServer) {
+      ((SafeConcurrentUpdateSolrServer) s).clearException();
     }
   }
 
@@ -94,8 +96,9 @@ public class SolrServerDocumentLoader implements DocumentLoader {
       sendBatch();
     }
     if (numSentItems > 0) {
-      if (server instanceof ConcurrentUpdateSolrServer) {
-        ((ConcurrentUpdateSolrServer) server).blockUntilFinished();
+      SolrServer s = getNonRetryingSolrServer();
+      if (s instanceof ConcurrentUpdateSolrServer) {
+        ((ConcurrentUpdateSolrServer) s).blockUntilFinished();
       }
     }
   }
@@ -165,7 +168,8 @@ public class SolrServerDocumentLoader implements DocumentLoader {
   @Override
   public UpdateResponse rollbackTransaction() throws SolrServerException, IOException {
     LOGGER.trace("rollback");
-    if (!(server instanceof CloudSolrServer)) {
+    SolrServer s = getNonRetryingSolrServer();
+    if (!(s instanceof CloudSolrServer)) {
       return server.rollback();
     } else {
       return new UpdateResponse();
@@ -184,6 +188,18 @@ public class SolrServerDocumentLoader implements DocumentLoader {
     return server.ping();
   }
 
+  public int getBatchSize() {
+    return batchSize;
+  }
+  
+  private SolrServer getNonRetryingSolrServer() {
+    SolrServer s = server;
+    while (s instanceof RetryingSolrServer) {
+      s = ((RetryingSolrServer)s).getUnderlyingSolrServer();
+    }
+    return s;
+  }
+
   public SolrServer getSolrServer() {
     return server;
   }
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetryTest.java b/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetryTest.java
new file mode 100644
index 0000000..5b179d9
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/FlexibleBoundedExponentialBackoffRetryTest.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.util.concurrent.TimeUnit;
+
+import org.junit.Assert;
+import org.junit.Test;
+
+
+public class FlexibleBoundedExponentialBackoffRetryTest extends Assert {
+
+  @Test
+  public void testBasic() throws Exception {
+    long baseSleepTimeNanos = 100;
+    long maxSleepNanos = 500;
+    int maxRetries = 100;
+    long maxElapsedTimeNanos = 5000;
+    RetryPolicy policy = new FlexibleBoundedExponentialBackoffRetry(
+        baseSleepTimeNanos, maxSleepNanos, maxRetries, maxElapsedTimeNanos);
+    long elapsedTimeNanos = 10;
+    CountingSleeper sleeper = new CountingSleeper();
+    for (int retryCount = 0; retryCount < maxRetries + 5; retryCount++) {
+      boolean retry = policy.allowRetry(retryCount, elapsedTimeNanos, sleeper);
+      if (retryCount < maxRetries) {
+        assertTrue(retry);
+        assertEquals(retryCount + 1, sleeper.count);
+      } else {
+        assertFalse(retry);
+        assertEquals(maxRetries, sleeper.count);
+      }
+      assertTrue(sleeper.time >= baseSleepTimeNanos);
+    }
+    
+    policy = new FlexibleBoundedExponentialBackoffRetry(
+        TimeUnit.SECONDS.toNanos(2), TimeUnit.SECONDS.toNanos(3), 100, TimeUnit.SECONDS.toNanos(4));
+    assertEquals(
+        "baseSleepTime[secs]:2.0, maxSleepTime[secs]:3.0, maxRetries:100, maxElapsedTime[secs]:4.0", 
+        policy.toString());
+    
+    policy = new FlexibleBoundedExponentialBackoffRetry(0, 0, maxRetries, maxElapsedTimeNanos);
+    sleeper = new CountingSleeper();
+    assertTrue(policy.allowRetry(0, elapsedTimeNanos, sleeper));
+    assertEquals(1, sleeper.count);
+    assertEquals(0, sleeper.time);
+    
+    assertFalse(policy.allowRetry(-1, elapsedTimeNanos, sleeper)); // negative retryCount
+    assertFalse(policy.allowRetry(0, maxElapsedTimeNanos, sleeper)); // reached maxElapsedTimeMs 
+    assertTrue(policy.allowRetry(0, 0, sleeper)); 
+    
+    policy = new FlexibleBoundedExponentialBackoffRetry(
+        Long.MAX_VALUE, Long.MAX_VALUE, maxRetries, maxElapsedTimeNanos);
+    sleeper = new CountingSleeper();
+    assertTrue(policy.allowRetry(0, elapsedTimeNanos, sleeper));
+    assertEquals(1, sleeper.count);
+    assertEquals(Long.MAX_VALUE, sleeper.time);
+    
+    try {
+      new FlexibleBoundedExponentialBackoffRetry(
+          -1, maxSleepNanos-1, maxRetries, maxElapsedTimeNanos);
+      fail();
+    } catch (IllegalArgumentException e) {
+      ; // expected
+    }
+    
+    try {
+      new FlexibleBoundedExponentialBackoffRetry(
+          baseSleepTimeNanos, maxSleepNanos, -1, maxElapsedTimeNanos);
+      fail();
+    } catch (IllegalArgumentException e) {
+      ; // expected
+    }
+    
+    try {
+      new FlexibleBoundedExponentialBackoffRetry(
+          baseSleepTimeNanos, baseSleepTimeNanos-1, maxRetries, maxElapsedTimeNanos);
+      fail();
+    } catch (IllegalArgumentException e) {
+      ; // expected
+    }
+    
+    try {
+      new FlexibleBoundedExponentialBackoffRetry(
+          baseSleepTimeNanos, maxSleepNanos, maxRetries, -1);
+      fail();
+    } catch (IllegalArgumentException e) {
+      ; // expected
+    }
+    
+  }
+  
+  
+  ///////////////////////////////////////////////////////////////////////////////
+  // Nested classes:
+  ///////////////////////////////////////////////////////////////////////////////
+  private static final class CountingSleeper implements RetrySleeper {
+    
+    int count = 0;
+    long time = 0;
+
+    @Override
+    public void sleepFor(long time, TimeUnit unit) throws InterruptedException {
+      this.count++;
+      this.time += time;
+    }
+    
+  }
+  
+}
diff --git a/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/RetryingSolrServerTest.java b/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/RetryingSolrServerTest.java
new file mode 100644
index 0000000..46502b7
--- /dev/null
+++ b/kite-morphlines/kite-morphlines-solr-core/src/test/java/org/apache/solr/client/solrj/retry/RetryingSolrServerTest.java
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2013 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.solr.client.solrj.retry;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.concurrent.TimeUnit;
+
+import org.apache.solr.SolrTestCaseJ4;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.SolrRequest;
+import org.apache.solr.client.solrj.SolrServer;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.beans.DocumentObjectBinder;
+import org.apache.solr.client.solrj.embedded.EmbeddedSolrServer;
+import org.apache.solr.common.SolrException;
+import org.apache.solr.common.SolrException.ErrorCode;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.util.NamedList;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+public class RetryingSolrServerTest extends SolrTestCaseJ4 {
+
+  private SolrServer solrServer;
+  
+  private static final String RESOURCES_DIR = "target" + File.separator + "test-classes";
+  private static final String DEFAULT_BASE_DIR = "solr";
+  
+  private static final Logger LOG = LoggerFactory.getLogger(RetryingSolrServerTest.class);
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    initCore(
+        "solrconfig.xml", 
+        "schema.xml",
+        RESOURCES_DIR + File.separator + DEFAULT_BASE_DIR
+    );    
+  }
+
+  @Before
+  public void setUp() throws Exception {
+    super.setUp();
+    solrServer = new EmbeddedSolrServer(h.getCoreContainer(), "");
+  }
+  
+  @Test
+  public void testNoRetries() throws Exception {
+    SolrQuery query = getDefaultQuery();
+    solrServer.query(query);
+    FailingSolrServer failingSolrServer = new FailingSolrServer(solrServer);
+    SolrServer solr = new RetryingSolrServer(failingSolrServer, getNoRetryPolicyFactory(), getMetricsFacade());
+    try {
+      solr.query(query);
+      fail();
+    } catch (RetriesExhaustedException e) {
+      assertTrue(e.getCause() instanceof FailingSolrServer.InjectedSolrServerException);
+      Assert.assertEquals(1, failingSolrServer.getNumRequests());
+      Assert.assertEquals(1, failingSolrServer.getNumInjectedFailures());
+    }    
+  }
+  
+  @Test
+  public void testRetryTwice() throws Exception {
+    SolrQuery query = getDefaultQuery();
+    solrServer.query(query);
+    FailingSolrServer failingSolrServer = new FailingSolrServer(solrServer);
+    SolrServer solr = new RetryingSolrServer(failingSolrServer, getRetryTwicePolicyFactory(), getMetricsFacade());
+    try {
+      solr.query(query);
+      fail();
+    } catch (RetriesExhaustedException e) {
+      Assert.assertTrue(e.getCause() instanceof FailingSolrServer.InjectedSolrServerException);
+      Assert.assertEquals(3, failingSolrServer.getNumRequests());
+      Assert.assertEquals(3, failingSolrServer.getNumInjectedFailures());
+      LOG.info("RetriesExhaustedException.getMessage(): " + e.getMessage());
+    }    
+  }
+  
+  @Test
+  public void testRetries() throws Exception {
+    new DefaultRetryPolicyFactory();
+    SolrQuery query = getDefaultQuery();
+    FailingSolrServer failingSolrServer = new FailingSolrServer(solrServer);
+    SolrServer solr = new RetryingSolrServer(
+        failingSolrServer, 
+        new DefaultRetryPolicyFactory(new FlexibleBoundedExponentialBackoffRetry(
+            TimeUnit.MILLISECONDS.toNanos(1), 
+            TimeUnit.MILLISECONDS.toNanos(1000), 
+            20, 
+            TimeUnit.MINUTES.toNanos(5))),
+        getMetricsFacade()
+        );
+    Assert.assertNotNull(solr.query(query));
+    Assert.assertEquals(FailingSolrServer.SUCCESS, failingSolrServer.getNumRequests());
+    Assert.assertEquals(FailingSolrServer.SUCCESS - 1, failingSolrServer.getNumInjectedFailures());
+    solr.query(query);
+    Assert.assertEquals(FailingSolrServer.SUCCESS + 1, failingSolrServer.getNumRequests());
+    Assert.assertEquals(FailingSolrServer.SUCCESS - 1, failingSolrServer.getNumInjectedFailures());
+
+    failingSolrServer.reset();
+    Assert.assertNotNull(solr.query(query));
+    Assert.assertEquals(FailingSolrServer.SUCCESS, failingSolrServer.getNumRequests());
+    Assert.assertEquals(FailingSolrServer.SUCCESS - 1, failingSolrServer.getNumInjectedFailures());
+    solr.query(query);
+    Assert.assertEquals(FailingSolrServer.SUCCESS + 1, failingSolrServer.getNumRequests());
+    Assert.assertEquals(FailingSolrServer.SUCCESS - 1, failingSolrServer.getNumInjectedFailures());
+    
+    // verify that after shutdown() is called, requests fail immediately without retries 
+    failingSolrServer.reset();
+    solr.shutdown();
+    try { 
+      solr.query(query);
+      fail();
+    } catch (RetriesExhaustedException e) {
+      assertTrue(e.getCause() instanceof FailingSolrServer.InjectedSolrServerException);
+      Assert.assertEquals(1, failingSolrServer.getNumRequests());
+      Assert.assertEquals(1, failingSolrServer.getNumInjectedFailures());
+    }
+  }
+
+  @Test
+  public void testRetryOfBadRequest() throws Exception {
+    SolrInputDocument doc = new SolrInputDocument(); // bad doc is missing 'id' field
+
+    // without RetryingSolrServer
+    try {
+      solrServer.add(doc); 
+      fail();
+    } catch (SolrException e) {
+      assertEquals(ErrorCode.BAD_REQUEST.code, e.code());
+    }
+        
+    // RetryingSolrServer, retry twice
+    CountingSolrServer countingSolrServer = new CountingSolrServer(solrServer);
+    SolrServer solr = new RetryingSolrServer(countingSolrServer, getRetryTwicePolicyFactory(), getMetricsFacade());
+    try {
+      solr.add(doc);
+      fail();
+    } catch (RetriesExhaustedException e) {
+      Assert.assertEquals(3, countingSolrServer.getNumRequests());
+      Assert.assertTrue(e.getCause() instanceof SolrException);
+      SolrException sex = (SolrException) e.getCause(); 
+      Assert.assertEquals(ErrorCode.BAD_REQUEST.code, sex.code());
+    }    
+  }
+  
+  @Test
+  public void testGetUnderlyingSolrServer() throws Exception {
+    RetryingSolrServer retryingSolr = new RetryingSolrServer(solrServer, getNoRetryPolicyFactory(), getMetricsFacade());
+    assertSame(solrServer, retryingSolr.getUnderlyingSolrServer());
+  }
+  
+  @Test
+  public void testGetBinder() throws Exception {
+    RetryingSolrServer retryingSolr = new RetryingSolrServer(solrServer, getNoRetryPolicyFactory(), getMetricsFacade());
+    assertSame(solrServer.getBinder(), retryingSolr.getBinder());
+  }
+
+  @Test
+  public void testNormalizeRequestKey() throws Exception {
+    assertEquals("&NOW=<redacted>", normalizeRequestKey("&NOW=1448689151133"));    
+  }
+
+  @Test
+  public void testGetExceptionKey() throws Exception {
+    // matching:
+    assertEquals(" UnknownHostException: <redacted>.foo.bar.com ", getExceptionKey(" UnknownHostException: vb0706.foo.bar.com "));
+    assertEquals(" collection: collection1 slice: shard<redacted> ", getExceptionKey(" collection: collection1 slice: shard130 "));
+    assertEquals(" _SHARD<redacted>_REPLICA<redacted> ", getExceptionKey(" _SHARD110_REPLICA3 "));
+
+    assertEquals("Xhttps://<redacted>.foo.bar.com:8983y", getExceptionKey("Xhttps://vb0706.foo.bar.com:8983y"));
+    assertEquals("Xhttp://<redacted>.foo.bar.com", getExceptionKey("Xhttp://vb0706.foo.bar.com")); // no port
+    assertEquals("Xhttp://<redacted>.foo.bar.com/", getExceptionKey("Xhttp://vb0706.foo.bar.com/")); // no port
+    assertEquals("Xhttp://<redacted>.foo.bar.com]", getExceptionKey("Xhttp://vb0706.foo.bar.com]")); // no port
+    assertEquals("Xhttp%3A%2F%2F<redacted>.foo.bar.com]", getExceptionKey("Xhttp%3A%2F%2Fvb0706.foo.bar.com]")); // escaped ://
+    
+    assertEquals("ftp://<redacted>.foo.bar:8983/some/path", getExceptionKey("ftp://vb0706.foo.bar:8983/some/path")); // with path
+    assertEquals("Ftp+-.://<redacted>.foo.bar:8983/some/path", getExceptionKey("Ftp+-.://vb0706.foo.bar:8983/some/path")); // scheme with plus, minus and dot
+    
+    assertEquals("insertAndQueryTweets_shard<redacted>_replica<redacted>", getExceptionKey("insertAndQueryTweets_shard30_replica3"));
+
+    assertEquals("foo bar", getExceptionKey("foo  bar")); // whitespace
+    assertEquals("foo bar", getExceptionKey("foo\nbar")); // whitespace
+    assertEquals("foo bar", getExceptionKey("foo\n\tbar")); // whitespace
+
+    assertEquals("IOException msg", getExceptionKey("java.io.IOException msg")); // omit package name of well known Exception classes
+
+    // not matching:
+    String str;
+    assertEquals(str = "Xhttps:/vb0706.foo.bar.com:8983y", getExceptionKey(str)); // missing ://
+    assertEquals(str = "://vb0706.foo.bar.com:8983y", getExceptionKey(str)); // missing scheme
+    assertEquals(str = "foo", getExceptionKey(str));
+  }
+  
+  private String getExceptionKey(final String str) {
+    RetryingSolrServer solr = new RetryingSolrServer(solrServer, getNoRetryPolicyFactory(), getMetricsFacade());
+    return solr.getExceptionKey(new Throwable() {
+      @Override
+      public String toString() {
+        return str;
+      }          
+    });    
+  }
+  
+  private String normalizeRequestKey(String str) {
+    RetryingSolrServer solr = new RetryingSolrServer(solrServer, getNoRetryPolicyFactory(), getMetricsFacade());
+    return solr.normalizeRequestKey(str);
+  }
+  
+  private RetryPolicyFactory getRetryTwicePolicyFactory() {
+    return new RetryPolicyFactory() {
+
+      @Override
+      public RetryPolicy getRetryPolicy(Throwable exception, SolrRequest request, SolrServer server,
+          RetryPolicy currentPolicy) {
+        if (currentPolicy == null) {
+          return new FlexibleBoundedExponentialBackoffRetry(0, 0, 2, Long.MAX_VALUE);
+        } else {
+          return currentPolicy;
+        }
+      }
+      
+    };
+  }
+  
+  private RetryPolicyFactory getNoRetryPolicyFactory() {
+    return new RetryPolicyFactory() {
+
+      @Override
+      public RetryPolicy getRetryPolicy(Throwable exception, SolrRequest request, SolrServer server,
+          RetryPolicy currentPolicy) {
+        return null;
+      }
+      
+    };
+  }
+  
+  private SolrQuery getDefaultQuery() {
+    return new SolrQuery("*:*").addFilterQuery("id:choreRunner_12_56");
+  }
+  
+  private MetricsFacade getMetricsFacade() {
+//    return new CodahaleMetricsFacade(new MetricRegistry(), new TDigestMetricBuilders());
+    return new MetricsFacade() {
+      
+      @Override
+      public void updateTimer(String name, long duration, TimeUnit unit) {
+        LOG.info("updateTimer name:{}, duration:{}, unit:{}", Arrays.asList(name, duration, unit));
+      }
+      
+      @Override
+      public void updateHistogram(String name, long value) {
+        LOG.info("updateHistogram name:{}, value:{}", name, value);
+      }
+      
+      @Override
+      public void markMeter(String name, long increment) {
+        LOG.info("markMeter name:{}, increment:{}", name, increment);
+      }
+    };
+  }
+
+  
+  ///////////////////////////////////////////////////////////////////////////////
+  // Nested classes:
+  ///////////////////////////////////////////////////////////////////////////////
+  /** Helper that counts the number of solrj requests */
+  private static final class CountingSolrServer extends SolrServer {
+    
+    private final SolrServer solrServer;
+    private long numRequests = 0;
+    
+    public CountingSolrServer(SolrServer solrServer) {
+      this.solrServer = solrServer;
+    }
+   
+    public long getNumRequests() {
+      return numRequests;
+    }
+    
+    @Override
+    public NamedList<Object> request(final SolrRequest request) throws SolrServerException, IOException {
+      numRequests++;
+      return solrServer.request(request);
+    }
+    
+    @Override
+    public DocumentObjectBinder getBinder() {
+      return solrServer.getBinder();
+    }
+
+    @Override
+    public void shutdown() {
+      // NOP necessary for testing with EmbeddedSolrServer
+      // solrServer.shutdown();
+    }
+  }
+  
+    
+  ///////////////////////////////////////////////////////////////////////////////
+  // Nested classes:
+  ///////////////////////////////////////////////////////////////////////////////
+  /**
+   * Test helper that simulates an erratic SolrServer. Injects exceptions on the first N solrj
+   * requests and succeeds on requests thereafter.
+   */
+  private static final class FailingSolrServer extends SolrServer {
+    
+    private final SolrServer solrServer;
+    private long numRequests = 0;
+    private long numInjectedFailures = 0;
+    
+    public static final int SUCCESS = 5;
+    
+    public FailingSolrServer(SolrServer solrServer) {
+      this.solrServer = solrServer;
+    }
+   
+    public long getNumRequests() {
+      return numRequests;
+    }
+    
+    public long getNumInjectedFailures() {
+      return numInjectedFailures;
+    }
+
+    public void reset() {
+      numRequests = 0;
+      numInjectedFailures = 0;
+    }
+
+    @Override
+    public NamedList<Object> request(final SolrRequest request) throws SolrServerException, IOException {
+      if (++numRequests < SUCCESS) {
+        numInjectedFailures++;
+        if (numRequests % 2 == 0) {
+          throw new InjectedSolrServerException("Injected failure");
+        }
+        try {
+          throw new InjectedSolrServerException("Nested injected failure");
+        } catch (InjectedSolrServerException e) {
+          throw new InjectedSolrServerException("Injected failure", e); 
+        }
+      }
+      return solrServer.request(request);
+    }
+    
+    @Override
+    public DocumentObjectBinder getBinder() {
+      return solrServer.getBinder();
+    }
+
+    @Override
+    public void shutdown() {
+      // NOP necessary for testing with EmbeddedSolrServer
+      // solrServer.shutdown();
+    }
+
+    
+    ///////////////////////////////////////////////////////////////////////////////
+    // Nested classes:
+    ///////////////////////////////////////////////////////////////////////////////
+    public static final class InjectedSolrServerException extends SolrServerException {
+
+      public InjectedSolrServerException(String message) {
+        super(message);        
+      }
+      
+      public InjectedSolrServerException(String message, Throwable cause) {
+        super(message, cause);        
+      }
+      
+    }
+  }
+  
+}
-- 
1.7.9.5

