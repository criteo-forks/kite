From e1b530a3c8d0acbad9a8ee7b9ffdd3dbe67b5254 Mon Sep 17 00:00:00 2001
From: Prasanna Rajaperumal <prasanna@cloudera.com>
Date: Tue, 24 Mar 2015 13:12:02 -0700
Subject: [PATCH 031/115] CDK-968: Add HBaseActionModifiable to SPI.

Implement HBaseActionModifiable SPI to allow HBase level hookups into
HBase Get/Put/Scan/Delete.
---
 .../java/org/kitesdk/data/hbase/DaoDataset.java    |   96 ++++++++-
 .../kitesdk/data/hbase/impl/CompositeBaseDao.java  |    3 +
 .../data/hbase/impl/HBaseClientTemplate.java       |  125 ++++++++----
 .../data/hbase/spi/HBaseActionModifiable.java      |  134 +++++++++++
 .../data/hbase/spi/TestHBaseActionModifiable.java  |  231 ++++++++++++++++++++
 5 files changed, 549 insertions(+), 40 deletions(-)
 create mode 100644 kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/spi/HBaseActionModifiable.java
 create mode 100644 kite-data/kite-data-hbase/src/test/java/org/kitesdk/data/hbase/spi/TestHBaseActionModifiable.java

diff --git a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/DaoDataset.java b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/DaoDataset.java
index 04e9021..47a9ef3 100644
--- a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/DaoDataset.java
+++ b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/DaoDataset.java
@@ -17,11 +17,20 @@ package org.kitesdk.data.hbase;
 
 import com.google.common.base.Preconditions;
 import java.net.URI;
+import java.util.List;
+
 import org.apache.avro.generic.IndexedRecord;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.mapreduce.InputFormat;
 import org.kitesdk.data.DatasetDescriptor;
 import org.kitesdk.data.Key;
+import org.kitesdk.data.hbase.impl.BaseDao;
+import org.kitesdk.data.hbase.impl.CompositeBaseDao;
+import org.kitesdk.data.hbase.impl.DeleteActionModifier;
+import org.kitesdk.data.hbase.impl.GetModifier;
+import org.kitesdk.data.hbase.impl.PutActionModifier;
+import org.kitesdk.data.hbase.impl.ScanModifier;
+import org.kitesdk.data.hbase.spi.HBaseActionModifiable;
 import org.kitesdk.data.impl.Accessor;
 import org.kitesdk.data.spi.PartitionKey;
 import org.kitesdk.data.PartitionStrategy;
@@ -33,7 +42,7 @@ import org.kitesdk.data.spi.Constraints;
 import org.kitesdk.data.spi.InputFormatAccessor;
 
 class DaoDataset<E> extends AbstractDataset<E> implements RandomAccessDataset<E>,
-    InputFormatAccessor<E> {
+    InputFormatAccessor<E>, HBaseActionModifiable {
 
   private final String namespace;
   private final String name;
@@ -140,4 +149,89 @@ class DaoDataset<E> extends AbstractDataset<E> implements RandomAccessDataset<E>
   public InputFormat<E, Void> getInputFormat(Configuration conf) {
     return new HBaseViewKeyInputFormat<E>(this);
   }
+
+  @SuppressWarnings("unchecked")
+  private BaseDao<E> getBaseDao() {
+    Dao<E> dao = getDao();
+    if(dao instanceof CompositeBaseDao) {
+      dao = ((CompositeBaseDao) dao).getDao();
+    }
+    if (dao instanceof BaseDao) {
+      return (BaseDao<E>) dao;
+    }
+    throw new UnsupportedOperationException(
+        "Action not supported for Dao " + dao.getClass());
+  }
+
+  @Override
+  public void registerGetModifier(GetModifier getModifier) {
+    getBaseDao().getHBaseClientTemplate().registerGetModifier(getModifier);
+  }
+
+  @Override
+  public List<GetModifier> getGetModifiers() {
+    return getBaseDao().getHBaseClientTemplate().getGetModifiers();
+  }
+
+  @Override
+  public void registerPutActionModifier(
+      PutActionModifier putActionModifier) {
+    getBaseDao().getHBaseClientTemplate()
+        .registerPutActionModifier(putActionModifier);
+  }
+
+  @Override
+  public List<PutActionModifier> getPutActionModifiers() {
+    return getBaseDao().getHBaseClientTemplate().getPutActionModifiers();
+  }
+
+  @Override
+  public void registerDeleteModifier(
+      DeleteActionModifier deleteActionModifier) {
+    getBaseDao().getHBaseClientTemplate()
+        .registerDeleteModifier(deleteActionModifier);
+  }
+
+  @Override
+  public List<DeleteActionModifier> getDeleteActionModifiers() {
+    return getBaseDao().getHBaseClientTemplate().getDeleteActionModifiers();
+  }
+
+  @Override
+  public void registerScanModifier(ScanModifier scanModifier) {
+    getBaseDao().getHBaseClientTemplate().registerScanModifier(scanModifier);
+  }
+
+  @Override
+  public List<ScanModifier> getScanModifiers() {
+    return getBaseDao().getHBaseClientTemplate().getScanModifiers();
+  }
+
+  @Override
+  public void clearGetModifiers() {
+    getBaseDao().getHBaseClientTemplate().clearGetModifiers();
+  }
+
+  @Override
+  public void clearPutActionModifiers() {
+    getBaseDao().getHBaseClientTemplate().clearPutActionModifiers();
+  }
+
+  @Override
+  public void clearDeleteActionModifiers() {
+    getBaseDao().getHBaseClientTemplate().clearDeleteActionModifiers();
+  }
+
+  @Override
+  public void clearScanModifiers() {
+    getBaseDao().getHBaseClientTemplate().clearScanModifiers();
+  }
+
+  @Override
+  public void clearAllModifiers() {
+    clearGetModifiers();
+    clearPutActionModifiers();
+    clearDeleteActionModifiers();
+    clearScanModifiers();
+  }
 }
diff --git a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/CompositeBaseDao.java b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/CompositeBaseDao.java
index 4725304..81d6426 100644
--- a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/CompositeBaseDao.java
+++ b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/CompositeBaseDao.java
@@ -246,4 +246,7 @@ public abstract class CompositeBaseDao<E, S> implements CompositeDao<E, S> {
     return baseDao.getPartitionStrategy();
   }
 
+  public Dao<E> getDao() {
+    return baseDao;
+  }
 }
diff --git a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/HBaseClientTemplate.java b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/HBaseClientTemplate.java
index 479558d..28a7a78 100644
--- a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/HBaseClientTemplate.java
+++ b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/impl/HBaseClientTemplate.java
@@ -15,6 +15,7 @@
  */
 package org.kitesdk.data.hbase.impl;
 
+import com.google.common.collect.ImmutableList;
 import org.kitesdk.data.DatasetIOException;
 import org.kitesdk.data.spi.PartitionKey;
 import com.google.common.annotations.VisibleForTesting;
@@ -82,44 +83,60 @@ public class HBaseClientTemplate {
 
   /**
    * Register a GetModifier to be called before every Get is executed on HBase.
-   * Multiple GetModifiers can be registered by invoking this function multiple
-   * times. GetModifiers will be called in the order they are added to the
+   * This GetModifier will be replaced if already registered and added if not.
+   * Equality is checked by calling the equals() on the getModifier passed.
+   * GetModifiers will be called in the order they are added to the
    * template, so if any modifier is destructive, it must be added in the right
    * order.
-   * 
-   * @param getModifier
-   *          The GetModifier to register.
+   *
+   * Not Thread Safe
+   * @param getModifier The GetModifier to register.
    */
   public void registerGetModifier(GetModifier getModifier) {
-    getModifiers.add(getModifier);
+    int currentIndex = getModifiers.indexOf(getModifier);
+    if(currentIndex == -1) {
+      getModifiers.add(getModifier);
+    } else {
+      getModifiers.set(currentIndex, getModifier);
+    }
+  }
+
+  /**
+   * Returns a list of Get Modifiers currently registered
+   *
+   * @return List of GetModifier
+   */
+  public List<GetModifier> getGetModifiers() {
+    return ImmutableList.copyOf(getModifiers);
   }
 
   /**
    * Register a PutActionModifier to be called before every Put is executed on
-   * HBase. Multiple PutActionModifiers can be registered by invoking this
-   * function multiple times. PutActionModifiers will be called in the order
-   * they are added to the template, so if any modifier is destructive, it must
-   * be added in the right order.
-   * 
-   * @param putActionModifier
-   *          The PutActionModifier to register.
+   * HBase. This PutActionModifier will be replaced if already registered and
+   * added if not. Equality is checked by calling the equals() on the
+   * putActionModifier passed. PutActionModifiers will be called in the order
+   * they are added, so if any modifier is destructive,
+   * it must be added in the right order.
+   *
+   * Not Thread Safe
+   * @param putActionModifier The PutActionModifier to register.
    */
   public void registerPutActionModifier(PutActionModifier putActionModifier) {
-    putActionModifiers.add(putActionModifier);
+    int currentIndex = putActionModifiers.indexOf(putActionModifier);
+    if(currentIndex == -1) {
+      putActionModifiers.add(putActionModifier);
+    } else {
+      putActionModifiers.set(currentIndex, putActionModifier);
+    }
   }
 
   /**
-   * Registers a PutActionModifier to be called before every Put, if the given
-   * modifier is not already registered. This allows the user to prevent adding
-   * the same modifier multiple times.
-   * 
-   * @param putActionModifier
+   * Returns a list of Put Modifiers currently registered
+   *
+   * @return List of PutActionModifier
    */
-  public void registerUniquePutActionModifier(
-      PutActionModifier putActionModifier) {
-    if (!putActionModifiers.contains(putActionModifier)) {
-      registerPutActionModifier(putActionModifier);
-    }
+  public List<PutActionModifier> getPutActionModifiers() {
+    return ImmutableList.copyOf(putActionModifiers);
   }
 
   @VisibleForTesting
@@ -129,30 +146,60 @@ public class HBaseClientTemplate {
 
   /**
    * Register a DeleteActionModifier to be called before every Delete is
-   * executed on HBase. Multiple DeleteActionModifiers can be registered by
-   * invoking this function multiple times. DeleteActionModifiers will be called
-   * in the order they are added to the template, so if any modifier is
-   * destructive, it must be added in the right order.
-   * 
-   * @param deleteActionModifier
-   *          The DeleteActionModifier to register.
+   * executed on HBase. This DeleteActionModifier will be replaced if already
+   * registered and added if its not. Equality is checked by calling the equals()
+   * on the deleteActionModifier passed. DeleteActionModifiers will be called
+   * in the order they are added, so if any modifier is destructive,
+   * it must be added in the right order.
+   *
+   * Not Thread Safe
+   * @param deleteActionModifier The DeleteActionModifier to register.
    */
   public void registerDeleteModifier(DeleteActionModifier deleteActionModifier) {
-    deleteActionModifiers.add(deleteActionModifier);
+    int currentIndex = deleteActionModifiers.indexOf(deleteActionModifier);
+    if(currentIndex == -1) {
+      deleteActionModifiers.add(deleteActionModifier);
+    } else {
+      deleteActionModifiers.set(currentIndex, deleteActionModifier);
+    }
+  }
+
+  /**
+   * Returns a list of Delete Modifiers currently registered
+   *
+   * @return List of DeleteActionModifier
+   */
+  public List<DeleteActionModifier> getDeleteActionModifiers() {
+    return ImmutableList.copyOf(deleteActionModifiers);
   }
 
   /**
    * Register a ScanModifier to be called before every Scan is executed on
-   * HBase. Multiple ScanModifiers can be registered by invoking this function
-   * multiple times. ScanModifiers will be called in the order they are added to
-   * the template, so if any modifier is destructive, it must be added in the
+   * HBase. This ScanModifier will be replaced if already registered and added
+   * if not. Equality is checked by calling the equals() on the scanModifier passed.
+   * ScanModifiers will be called in the order they are added,
+   * so if any modifier is destructive, it must be added in the
    * right order.
-   * 
-   * @param scanModifier
-   *          The ScanModifier to register.
+   *
+   * Not Thread Safe
+   * @param scanModifier The ScanModifier to register.
    */
   public void registerScanModifier(ScanModifier scanModifier) {
-    scanModifiers.add(scanModifier);
+    int currentIndex = scanModifiers.indexOf(scanModifier);
+    if(currentIndex == -1) {
+      scanModifiers.add(scanModifier);
+    } else {
+      scanModifiers.set(currentIndex, scanModifier);
+    }
+  }
+
+  /**
+   * Returns a list of Scan Modifiers currently registered
+   *
+   * @return List of ScanModifier
+   */
+  public List<ScanModifier> getScanModifiers() {
+    return ImmutableList.copyOf(scanModifiers);
   }
 
   /**
diff --git a/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/spi/HBaseActionModifiable.java b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/spi/HBaseActionModifiable.java
new file mode 100644
index 0000000..e53785f
--- /dev/null
+++ b/kite-data/kite-data-hbase/src/main/java/org/kitesdk/data/hbase/spi/HBaseActionModifiable.java
@@ -0,0 +1,134 @@
+/**
+ * Copyright 2015 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kitesdk.data.hbase.spi;
+
+import org.kitesdk.data.hbase.impl.DeleteActionModifier;
+import org.kitesdk.data.hbase.impl.GetModifier;
+import org.kitesdk.data.hbase.impl.PutActionModifier;
+import org.kitesdk.data.hbase.impl.ScanModifier;
+
+import java.util.List;
+
+/**
+ * Allows SPI hooks into HBase Actions (GET/SCAN/PUT/DELETE).
+ * Any hooks added is persistent on the Dataset Views, Readers and Writers.
+ * ActionModifier needs to be removed manually
+ */
+public interface HBaseActionModifiable {
+  /**
+   * Register a GetModifier to be called before every Get is executed on HBase.
+   * This GetModifier will be replaced if already registered and added if not.
+   * Equality is checked by calling the equals() on the getModifier passed.
+   * GetModifiers will be called in the order they are added to the
+   * template, so if any modifier is destructive, it must be added in the right
+   * order.
+   *
+   * @param getModifier The GetModifier to register.
+   */
+  void registerGetModifier(GetModifier getModifier);
+
+  /**
+   * Returns a list of Get Modifiers currently registered
+   *
+   * @return List of GetModifier
+   */
+  List<GetModifier> getGetModifiers();
+
+  /**
+   * Register a PutActionModifier to be called before every Put is executed on
+   * HBase. This PutActionModifier will be replaced if already registered and
+   * added if not. Equality is checked by calling the equals() on the
+   * putActionModifier passed. PutActionModifiers will be called in the order
+   * they are added, so if any modifier is destructive,
+   * it must be added in the right order.
+   *
+   * @param putActionModifier The PutActionModifier to register.
+   */
+  void registerPutActionModifier(PutActionModifier putActionModifier);
+
+  /**
+   * Returns a list of Put Modifiers currently registered
+   *
+   * @return List of PutActionModifier
+   */
+  List<PutActionModifier> getPutActionModifiers();
+
+  /**
+   * Register a DeleteActionModifier to be called before every Delete is
+   * executed on HBase. This DeleteActionModifier will be replaced if already
+   * registered and added if its not. Equality is checked by calling the equals()
+   * on the deleteActionModifier passed. DeleteActionModifiers will be called
+   * in the order they are added, so if any modifier is destructive,
+   * it must be added in the right order.
+   *
+   * @param deleteActionModifier The DeleteActionModifier to register.
+   */
+  void registerDeleteModifier(DeleteActionModifier deleteActionModifier);
+
+  /**
+   * Returns a list of Delete Modifiers currently registered
+   *
+   * @return List of DeleteActionModifier
+   */
+  List<DeleteActionModifier> getDeleteActionModifiers();
+
+  /**
+   * Register a ScanModifier to be called before every Scan is executed on
+   * HBase. This ScanModifier will be replaced if already registered and added
+   * if not. Equality is checked by calling the equals() on the scanModifier passed.
+   * ScanModifiers will be called in the order they are added,
+   * so if any modifier is destructive, it must be added in the
+   * right order.
+   *
+   * @param scanModifier The ScanModifier to register.
+   */
+  void registerScanModifier(ScanModifier scanModifier);
+
+  /**
+   * Returns a list of Scan Modifiers currently registered
+   *
+   * @return List of ScanModifier
+   */
+  List<ScanModifier> getScanModifiers();
+
+  /**
+   * Clear all GetModifiers registered with registerGetModifier.
+   */
+  void clearGetModifiers();
+
+  /**
+   * Clear all PutActionModifiers registered with registerPutActionModifier.
+   */
+  void clearPutActionModifiers();
+
+  /**
+   * Clear all DeleteActionModifiers registered with
+   * registerDeleteActionModifier.
+   */
+  void clearDeleteActionModifiers();
+
+  /**
+   * Clear all ScanModifiers registered with registerScanModifier.
+   */
+  void clearScanModifiers();
+
+  /**
+   * Clear all modifiers registered with the template for all operations.
+   */
+  void clearAllModifiers();
+
+}
diff --git a/kite-data/kite-data-hbase/src/test/java/org/kitesdk/data/hbase/spi/TestHBaseActionModifiable.java b/kite-data/kite-data-hbase/src/test/java/org/kitesdk/data/hbase/spi/TestHBaseActionModifiable.java
new file mode 100644
index 0000000..0319e7a
--- /dev/null
+++ b/kite-data/kite-data-hbase/src/test/java/org/kitesdk/data/hbase/spi/TestHBaseActionModifiable.java
@@ -0,0 +1,231 @@
+/**
+ * Copyright 2015 Cloudera Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.kitesdk.data.hbase.spi;
+
+import org.apache.hadoop.hbase.client.Put;
+import org.apache.hadoop.hbase.client.Scan;
+import org.apache.hadoop.hbase.filter.CompareFilter;
+import org.apache.hadoop.hbase.filter.SingleColumnValueFilter;
+import org.apache.hadoop.hbase.util.Bytes;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.kitesdk.data.DatasetDescriptor;
+import org.kitesdk.data.DatasetReader;
+import org.kitesdk.data.RandomAccessDataset;
+import org.kitesdk.data.hbase.HBaseDatasetRepository;
+import org.kitesdk.data.hbase.HBaseDatasetRepositoryTest;
+import org.kitesdk.data.hbase.avro.AvroUtils;
+import org.kitesdk.data.hbase.avro.entities.ArrayRecord;
+import org.kitesdk.data.hbase.avro.entities.EmbeddedRecord;
+import org.kitesdk.data.hbase.avro.entities.TestEntity;
+import org.kitesdk.data.hbase.avro.entities.TestEnum;
+import org.kitesdk.data.hbase.impl.PutAction;
+import org.kitesdk.data.hbase.impl.PutActionModifier;
+import org.kitesdk.data.hbase.impl.ScanModifier;
+import org.kitesdk.data.hbase.testing.HBaseTestUtils;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test for registering action modifiers
+ */
+public class TestHBaseActionModifiable {
+  private static final String testEntity;
+  private static final String tableName = "testtable";
+  private static final String managedTableName = "managed_schemas";
+  private HBaseDatasetRepository repo;
+  private RandomAccessDataset<TestEntity> ds;
+
+  static {
+    try {
+      testEntity = AvroUtils.inputStreamToString(
+          HBaseDatasetRepositoryTest.class
+              .getResourceAsStream("/TestEntity.avsc"));
+    } catch (Exception e) {
+      throw new RuntimeException(e);
+    }
+  }
+
+  @BeforeClass
+  public static void beforeClass() throws Exception {
+    HBaseTestUtils.getMiniCluster();
+    // managed table should be created by HBaseDatasetRepository
+    HBaseTestUtils.util.deleteTable(Bytes.toBytes(managedTableName));
+  }
+
+  @AfterClass
+  public static void afterClass() throws Exception {
+    HBaseTestUtils.util.deleteTable(Bytes.toBytes(tableName));
+  }
+
+  @Before
+  public void setup() throws Exception {
+    repo = new HBaseDatasetRepository.Builder()
+        .configuration(HBaseTestUtils.getConf()).build();
+    DatasetDescriptor descriptor = new DatasetDescriptor.Builder()
+        .schemaLiteral(testEntity).build();
+    ds = repo.create("default", tableName, descriptor, TestEntity.class);
+  }
+
+  @After
+  public void after() throws Exception {
+    ((HBaseActionModifiable) ds).clearAllModifiers();
+    repo.delete("default", tableName);
+    HBaseTestUtils.util.truncateTable(Bytes.toBytes(tableName));
+    HBaseTestUtils.util.truncateTable(Bytes.toBytes(managedTableName));
+  }
+
+  @Test
+  public void testGetActionModifiers() {
+    HBaseActionModifiable amd = (HBaseActionModifiable) ds;
+    PutActionModifier putActionModifier = newPutActionModifier("testModifierId",
+        "TestValue");
+    amd.registerPutActionModifier(putActionModifier);
+    ScanModifier scanModifier = newScanModifier("OtherTestValue");
+    amd.registerScanModifier(scanModifier);
+
+    assertTrue(amd.getGetModifiers().isEmpty());
+    assertTrue(amd.getDeleteActionModifiers().isEmpty());
+    assertEquals(1, amd.getPutActionModifiers().size());
+    assertEquals(putActionModifier, amd.getPutActionModifiers().get(0));
+    assertEquals(1, amd.getScanModifiers().size());
+    assertEquals(scanModifier, amd.getScanModifiers().get(0));
+  }
+
+  @Test
+  public void testPutScanActionModifiers() {
+    HBaseActionModifiable amd = (HBaseActionModifiable) ds;
+    amd.registerPutActionModifier(
+        newPutActionModifier("testModifierId", "TestValue"));
+    saveTestEntity(newTestEntity());
+    amd.registerScanModifier(newScanModifier("OtherTestValue"));
+    checkRecord(false);
+
+    amd.clearScanModifiers();
+    amd.registerScanModifier(newScanModifier("TestValue"));
+    checkRecord(true);
+  }
+
+  @Test
+  public void testDuplicatePutActionModifiers() {
+    HBaseActionModifiable amd = (HBaseActionModifiable) ds;
+    // This should be replaced
+    amd.registerPutActionModifier(
+        newPutActionModifier("testModifiedId", "OtherTestValue"));
+    amd.registerPutActionModifier(
+        newPutActionModifier("testModifiedId", "TestValue"));
+
+    saveTestEntity(newTestEntity());
+
+    // Scan with OtherTestValue should not return any records
+    amd.registerScanModifier(newScanModifier("OtherTestValue"));
+    checkRecord(false);
+
+    amd.clearScanModifiers();
+    // Scan with TestValue should return records
+    amd.registerScanModifier(newScanModifier("TestValue"));
+    checkRecord(true);
+  }
+
+  private void checkRecord(boolean shouldExist) {
+    DatasetReader<TestEntity> dsReader = ds.newReader();
+    try {
+      if (shouldExist) {
+        assertTrue(dsReader.hasNext());
+      } else {
+        assertFalse(dsReader.hasNext());
+      }
+    } finally {
+      dsReader.close();
+    }
+  }
+
+  private ScanModifier newScanModifier(final String value) {
+    return new ScanModifier() {
+      @Override
+      public Scan modifyScan(Scan scan) {
+        scan.addColumn(Bytes.toBytes("meta"), Bytes.toBytes("testcf"));
+        SingleColumnValueFilter filter = new SingleColumnValueFilter(
+            Bytes.toBytes("meta"), Bytes.toBytes("testcf"),
+            CompareFilter.CompareOp.EQUAL, Bytes.toBytes(value));
+        filter.setFilterIfMissing(true);
+        scan.setFilter(filter);
+        return scan;
+      }
+    };
+  }
+
+  private PutActionModifier newPutActionModifier(String id, String value) {
+    return new TestPutActionModifier(id, value);
+  }
+
+  private void saveTestEntity(TestEntity entity) {
+    ds.put(entity);
+  }
+
+  private TestEntity newTestEntity() {
+    return TestEntity.newBuilder().setPart1("part1").setPart2("part2")
+        .setField1("field1").setField2("field2")
+        .setField3(new HashMap<String, String>()).setField4(
+            EmbeddedRecord.newBuilder().setEmbeddedField1("embeddedField1")
+                .setEmbeddedField2(2).build())
+        .setField5(new ArrayList<ArrayRecord>()).setEnum$(TestEnum.ENUM1)
+        .build();
+  }
+
+  private class TestPutActionModifier implements PutActionModifier {
+    private String id;
+    private String value;
+
+    public TestPutActionModifier(String id, String value) {
+      this.id = id;
+      this.value = value;
+    }
+
+    @Override
+    public PutAction modifyPutAction(PutAction putAction) {
+      Put put = putAction.getPut();
+      put.add(Bytes.toBytes("meta"), Bytes.toBytes("testcf"),
+          Bytes.toBytes(value));
+      return new PutAction(put);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o)
+        return true;
+      if (o == null || getClass() != o.getClass())
+        return false;
+      TestPutActionModifier that = (TestPutActionModifier) o;
+      return id.equals(that.id);
+    }
+
+    @Override
+    public int hashCode() {
+      return id.hashCode();
+    }
+  }
+
+}
-- 
1.7.0.4

